"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const vscode = require("vscode");
const Settings = require("../settings");
/**
 * Defines a pair line numbers which describes a potential folding range in a text document
 */
class LineNumberRange {
    constructor(rangeKind) {
        this.rangeKind = rangeKind;
    }
    /**
     * Build the range based on a pair of grammar tokens
     * @param start     The token where the range starts
     * @param end       The token where the range ends
     * @param document  The text document
     * @returns         Built LineNumberRange object
     */
    fromTokenPair(start, end, document) {
        this.startline = document.positionAt(start.startIndex).line;
        this.endline = document.positionAt(end.startIndex).line;
        return this;
    }
    /**
     * Build the range based on a pair of line numbers
     * @param startLine The line where the range starts
     * @param endLine   The line where the range ends
     * @returns         Built LineNumberRange object
     */
    fromLinePair(startLine, endLine) {
        this.startline = startLine;
        this.endline = endLine;
        return this;
    }
    /**
     * Whether this line number range, is a valid folding range in the document
     * @returns Whether the range passes all validation checks
     */
    isValidRange() {
        // Start and end lines must be defined and positive integers
        if (this.startline == null || this.endline == null) {
            return false;
        }
        if (this.startline < 0 || this.endline < 0) {
            return false;
        }
        // End line number cannot be before the start
        if (this.startline > this.endline) {
            return false;
        }
        // Folding ranges must span at least 2 lines
        return (this.endline - this.startline >= 1);
    }
    /**
     * Creates a vscode.FoldingRange object based on this object
     * @returns A Folding Range object for use with the Folding Provider
     */
    toFoldingRange() {
        return new vscode.FoldingRange(this.startline, this.endline, this.rangeKind);
    }
}
/**
 * A PowerShell syntax aware Folding Provider
 */
class FoldingProvider {
    constructor(powershellGrammar) {
        /**
         * These regular expressions are used to match lines which mark the start and end of region comment in a PowerShell
         * script. They are based on the defaults in the VS Code Language Configuration at;
         * https://github.com/Microsoft/vscode/blob/64186b0a26/extensions/powershell/language-configuration.json#L26-L31
         */
        this.startRegionText = /^\s*#region\b/i;
        this.endRegionText = /^\s*#endregion\b/i;
        /**
         * This regular expressions is used to detect a line comment (as opposed to an inline comment), that is not a region
         * block directive i.e.
         * - No text between the beginning of the line and `#`
         * - Comment does start with region
         * - Comment does start with endregion
         */
        this.lineCommentText = /\s*#(?!region\b|endregion\b)/i;
        this.powershellGrammar = powershellGrammar;
    }
    /**
     * Given a text document, parse the document and return a list of code folding ranges.
     * @param document  Text document to parse
     * @param context   Not used
     * @param token     Not used
     */
    provideFoldingRanges(document, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the grammar hasn't been setup correctly, return empty result
            if (this.powershellGrammar == null) {
                return [];
            }
            // Tokenize each line and build up an array of document-wide tokens
            // Note that line endings (CRLF/LF/CR) have interpolation issues so don't
            // tokenize an entire document if the line endings are variable.
            const tokens = new Array();
            let tokenizationState = null;
            for (let i = 0; i < document.lineCount; i++) {
                const result = this.powershellGrammar.tokenizeLine(document.lineAt(i).text, tokenizationState);
                const offset = document.offsetAt(new vscode.Position(i, 0));
                for (const item of result.tokens) {
                    // Add the offset of the line to translate a character offset into
                    // a document based index
                    item.startIndex += offset;
                    item.endIndex += offset;
                    tokens.push(item);
                }
                tokenizationState = result.ruleStack;
            }
            // Parse the token list looking for matching tokens and return
            // a list of LineNumberRange objects.  Then filter the list and only return matches
            // that are a valid folding range e.g. It meets a minimum line span limit
            const foldableRegions = this.extractFoldableRegions(tokens, document)
                .filter((item) => item.isValidRange());
            // Sort the list of matched tokens, starting at the top of the document,
            // and ensure that, in the case of multiple ranges starting the same line,
            // that the largest range (i.e. most number of lines spanned) is sorted
            // first.  This is needed as vscode will just ignore any duplicate folding
            // ranges.
            foldableRegions.sort((a, b) => {
                // Initially look at the start line
                if (a.startline > b.startline) {
                    return 1;
                }
                if (a.startline < b.startline) {
                    return -1;
                }
                // They have the same start line so now consider the end line.
                // The biggest line range is sorted first
                if (a.endline > b.endline) {
                    return -1;
                }
                if (a.endline < b.endline) {
                    return 1;
                }
                // They're the same
                return 0;
            });
            // Convert the matched token list into a FoldingRange[]
            const foldingRanges = [];
            foldableRegions.forEach((item) => { foldingRanges.push(item.toFoldingRange()); });
            return foldingRanges;
        });
    }
    /**
     * Given a start and end textmate scope name, find matching grammar tokens
     * and pair them together.  Uses a simple stack to take into account nested regions.
     * @param tokens         List of grammar tokens to parse
     * @param startScopeName The name of the starting scope to match
     * @param endScopeName   The name of the ending scope to match
     * @param matchType      The type of range this matched token pair represents e.g. A comment
     * @param document       The source text document
     * @returns              A list of LineNumberRange objects of the matched token scopes
     */
    matchScopeElements(tokens, startScopeName, endScopeName, matchType, document) {
        const result = [];
        const tokenStack = [];
        tokens.forEach((token) => {
            if (token.scopes.indexOf(startScopeName) !== -1) {
                tokenStack.push(token);
            }
            if ((tokenStack.length > 0) && (token.scopes.indexOf(endScopeName) !== -1)) {
                result.unshift((new LineNumberRange(matchType)).fromTokenPair(tokenStack.pop(), token, document));
            }
        });
        return result;
    }
    /**
     * Given a textmate scope name, find a series of contiguous tokens which contain
     * that scope name and pair them together.
     * @param tokens    List of grammar tokens to parse
     * @param scopeName The name of the scope to match
     * @param matchType The type of range this region represents e.g. A comment
     * @param document  The source text document
     * @returns         A list of LineNumberRange objects of the contiguous token scopes
     */
    matchContiguousScopeElements(tokens, scopeName, matchType, document) {
        const result = [];
        let startToken;
        tokens.forEach((token, index) => {
            if (token.scopes.indexOf(scopeName) !== -1) {
                if (startToken === undefined) {
                    startToken = token;
                }
                // If we're at the end of the token list, or the next token does not include the scopeName
                // we've reached the end of the contiguous block.
                if (((index + 1) >= tokens.length) || (tokens[index + 1].scopes.indexOf(scopeName) === -1)) {
                    result.push((new LineNumberRange(matchType)).fromTokenPair(startToken, token, document));
                    startToken = undefined;
                }
            }
        });
        return result;
    }
    /**
     * Given a zero based offset, find the line in the document
     * @param offset   Zero based offset in the document
     * @param document The source text document
     * @returns        The line at the offset
     */
    lineAtOffset(offset, document) {
        return document.lineAt(document.positionAt(offset));
    }
    /**
     * Finding blocks of comment tokens is more complicated as the newline characters are not
     * classed as comments.  To workaround this we search for the comment character `#` scope name
     * "punctuation.definition.comment.powershell" and then determine contiguous line numbers from there
     * @param tokens   List of grammar tokens to parse
     * @param document The source text document
     * @returns        A list of LineNumberRange objects for blocks of comment lines
     */
    matchBlockCommentScopeElements(tokens, document) {
        const result = [];
        let startLine = -1;
        let nextLine = -1;
        tokens.forEach((token) => {
            if (token.scopes.indexOf("punctuation.definition.comment.powershell") !== -1) {
                const line = this.lineAtOffset(token.startIndex, document);
                // The punctuation.definition.comment.powershell token matches new-line comments
                // and inline comments e.g. `$x = 'foo' # inline comment`.
                if (this.lineCommentText.test(line.text)) {
                    const lineNum = line.lineNumber;
                    // A simple pattern for keeping track of contiguous numbers in a known sorted array
                    if (startLine === -1) {
                        startLine = lineNum;
                    }
                    else if (lineNum !== nextLine) {
                        result.push((new LineNumberRange(vscode.FoldingRangeKind.Comment)).fromLinePair(startLine, nextLine - 1));
                        startLine = lineNum;
                    }
                    nextLine = lineNum + 1;
                }
            }
        });
        // If we exit the token array and we're still processing comment lines, then the
        // comment block simply ends at the end of document
        if (startLine !== -1) {
            result.push((new LineNumberRange(vscode.FoldingRangeKind.Comment)).fromLinePair(startLine, nextLine - 1));
        }
        return result;
    }
    /**
     * Create a new token object with an appended scopeName
     * @param token     The token to append the scope to
     * @param scopeName The scope name to append
     * @returns         A copy of the original token, but with the scope appended
     */
    addTokenScope(token, scopeName) {
        // Only a shallow clone is required
        const tokenClone = Object.assign({}, token);
        tokenClone.scopes.push(scopeName);
        return tokenClone;
    }
    /**
     * Given a list of grammar tokens, find the tokens that are comments and
     * the comment text is either `# region` or `# endregion`.  Return a new list of tokens
     * with custom scope names added, "custom.start.region" and "custom.end.region" respectively
     * @param tokens   List of grammar tokens to parse
     * @param document The source text document
     * @returns        A list of LineNumberRange objects of the line comment region blocks
     */
    extractRegionScopeElements(tokens, document) {
        const result = [];
        tokens.forEach((token) => {
            if (token.scopes.indexOf("punctuation.definition.comment.powershell") !== -1) {
                const line = this.lineAtOffset(token.startIndex, document).text;
                if (this.startRegionText.test(line)) {
                    result.push(this.addTokenScope(token, "custom.start.region"));
                }
                if (this.endRegionText.test(line)) {
                    result.push(this.addTokenScope(token, "custom.end.region"));
                }
            }
        });
        return result;
    }
    /**
     * Given a list of tokens, return a list of line number ranges which could be folding regions in the document
     * @param tokens   List of grammar tokens to parse
     * @param document The source text document
     * @returns        A list of LineNumberRange objects of the possible document folding regions
     */
    extractFoldableRegions(tokens, document) {
        const matchedTokens = [];
        // Find matching braces   { -> }
        this.matchScopeElements(tokens, "punctuation.section.braces.begin.powershell", "punctuation.section.braces.end.powershell", null, document)
            .forEach((match) => { matchedTokens.push(match); });
        // Find matching parentheses   ( -> )
        this.matchScopeElements(tokens, "punctuation.section.group.begin.powershell", "punctuation.section.group.end.powershell", null, document)
            .forEach((match) => { matchedTokens.push(match); });
        // Find contiguous here strings   @' -> '@
        this.matchContiguousScopeElements(tokens, "string.quoted.single.heredoc.powershell", null, document)
            .forEach((match) => { matchedTokens.push(match); });
        // Find contiguous here strings   @" -> "@
        this.matchContiguousScopeElements(tokens, "string.quoted.double.heredoc.powershell", null, document)
            .forEach((match) => { matchedTokens.push(match); });
        // Find matching comment regions   #region -> #endregion
        this.matchScopeElements(this.extractRegionScopeElements(tokens, document), "custom.start.region", "custom.end.region", vscode.FoldingRangeKind.Region, document)
            .forEach((match) => { matchedTokens.push(match); });
        // Find blocks of line comments   # comment1\n# comment2\n...
        this.matchBlockCommentScopeElements(tokens, document).forEach((match) => { matchedTokens.push(match); });
        // Find matching block comments   <# -> #>
        this.matchScopeElements(tokens, "punctuation.definition.comment.block.begin.powershell", "punctuation.definition.comment.block.end.powershell", vscode.FoldingRangeKind.Comment, document)
            .forEach((match) => { matchedTokens.push(match); });
        return matchedTokens;
    }
}
exports.FoldingProvider = FoldingProvider;
class FoldingFeature {
    /**
     * Constructs a handler for the FoldingProvider.  It returns success if the required grammar file can not be located
     * but does not regist a provider.  This causes VS Code to instead still use the indentation based provider
     * @param logger           The logging object to send messages to
     * @param documentSelector documentSelector object for this Folding Provider
     */
    constructor(logger, documentSelector) {
        this.logger = logger;
        const settings = Settings.load();
        if (!(settings.codeFolding && settings.codeFolding.enable)) {
            return;
        }
        this.loadPSGrammar(logger)
            .then((grammar) => {
            // If the PowerShell grammar is not available for some reason, don't register a folding provider,
            // which reverts VSCode to the default indentation style folding
            if (!grammar) {
                logger.writeWarning("Unable to load the PowerShell grammar file");
                return;
            }
            this.foldingProvider = new FoldingProvider(grammar);
            vscode.languages.registerFoldingRangeProvider(documentSelector, this.foldingProvider);
            logger.write("Syntax Folding Provider registered");
        }, (err) => {
            this.logger.writeError(`Failed to load grammar file - error: ${err}`);
        });
    }
    /* dispose() is required by the IFeature interface, but is not required by this feature */
    dispose() { return undefined; }
    /* setLanguageClient() is required by the IFeature interface, but is not required by this feature */
    setLanguageClient(languageclient) { return undefined; }
    /**
     * Returns the PowerShell grammar parser, from the vscode-textmate node module
     * @param logger The logging object to send messages to
     * @returns      A grammar parser for the PowerShell language is succesful or undefined if an error occured
     */
    loadPSGrammar(logger) {
        const tm = this.getCoreNodeModule("vscode-textmate", logger);
        if (tm == null) {
            return undefined;
        }
        logger.writeDiagnostic(`Loaded the vscode-textmate module`);
        const registry = new tm.Registry();
        if (registry == null) {
            return undefined;
        }
        logger.writeDiagnostic(`Created the textmate Registry`);
        const grammarPath = this.powerShellGrammarPath();
        if (grammarPath == null) {
            return undefined;
        }
        logger.writeDiagnostic(`PowerShell grammar file specified as ${grammarPath}`);
        // Branching for the different vscode-textmate modules
        if ("loadGrammarFromPathSync" in registry) {
            // V3 of the module allows synchronous loading of a grammar
            return new Promise((resolve) => {
                resolve(registry.loadGrammarFromPathSync(grammarPath));
            });
        }
        else {
            // However in V4+ this is async only
            const content = fs.readFileSync(grammarPath);
            const rawGrammar = tm.parseRawGrammar(content.toString(), grammarPath);
            return registry.addGrammar(rawGrammar);
        }
    }
    /**
     * Returns a node module installed within VSCode, or null if it fails.
     * Some node modules (e.g. vscode-textmate) cannot be required directly, instead the known module locations
     * must be tried. Documented in https://github.com/Microsoft/vscode/issues/46281
     * @param moduleName Name of the module to load e.g. vscode-textmate
     * @param logger     The logging object to send messages to
     * @returns          The required module, or null if the module cannot be required
     */
    getCoreNodeModule(moduleName, logger) {
        // Attempt to load the module from known locations
        const loadLocations = [
            `${vscode.env.appRoot}/node_modules.asar/${moduleName}`,
            `${vscode.env.appRoot}/node_modules/${moduleName}`,
        ];
        for (const filename of loadLocations) {
            try {
                const mod = require(filename);
                logger.writeDiagnostic(`Succesfully required ${filename}`);
                return mod;
            }
            catch (err) {
                logger.writeError(`Error while attempting to require ${filename}`, err);
            }
        }
        return null;
    }
    /**
     * Search all of the loaded extenions for the PowerShell grammar file
     * @returns The absolute path to the PowerShell grammar file.  Returns undefined if the path cannot be located.
     */
    powerShellGrammarPath() {
        // Go through all the extension packages and search for PowerShell grammars,
        // returning the path to the first we find
        for (const ext of vscode.extensions.all) {
            if (!(ext.packageJSON && ext.packageJSON.contributes && ext.packageJSON.contributes.grammars)) {
                continue;
            }
            for (const grammar of ext.packageJSON.contributes.grammars) {
                if (grammar.language !== "powershell") {
                    continue;
                }
                return path.join(ext.extensionPath, grammar.path);
            }
        }
        return undefined;
    }
}
exports.FoldingFeature = FoldingFeature;
//# sourceMappingURL=Folding.js.map