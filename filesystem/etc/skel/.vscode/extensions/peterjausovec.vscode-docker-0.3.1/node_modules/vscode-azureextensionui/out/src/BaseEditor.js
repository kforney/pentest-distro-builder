"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fse = require("fs-extra");
const path = require("path");
const vscode = require("vscode");
const DialogResponses_1 = require("./DialogResponses");
const errors_1 = require("./errors");
const extensionVariables_1 = require("./extensionVariables");
const localize_1 = require("./localize");
const createTemporaryFile_1 = require("./utils/createTemporaryFile");
// tslint:disable-next-line:no-unsafe-any
class BaseEditor {
    constructor(showSavePromptKey) {
        this.showSavePromptKey = showSavePromptKey;
        this.fileMap = {};
        this.ignoreSave = false;
    }
    showEditor(context, sizeLimit /* in Megabytes */) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = yield this.getFilename(context);
            this.appendLineToOutput(localize_1.localize('opening', 'Opening "{0}"...', fileName));
            if (sizeLimit !== undefined) {
                const size = yield this.getSize(context);
                if (size > sizeLimit) {
                    const message = localize_1.localize('tooLargeError', '"{0}" is too large to download.', fileName);
                    throw new Error(message);
                }
            }
            const localFilePath = yield createTemporaryFile_1.createTemporaryFile(fileName);
            const document = yield vscode.workspace.openTextDocument(localFilePath);
            this.fileMap[localFilePath] = [document, context];
            const data = yield this.getData(context);
            const textEditor = yield vscode.window.showTextDocument(document);
            yield this.updateEditor(data, textEditor);
        });
    }
    updateMatchingContext(doc) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = Object.keys(this.fileMap).find((fsPath) => path.relative(doc.fsPath, fsPath) === '');
            if (filePath) {
                const [textDocument, context] = this.fileMap[filePath];
                yield this.updateRemote(context, textDocument);
            }
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(this.fileMap).forEach((key) => __awaiter(this, void 0, void 0, function* () { return yield fse.remove(path.dirname(key)); }));
        });
    }
    onDidSaveTextDocument(actionContext, globalState, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            actionContext.suppressTelemetry = true;
            const filePath = Object.keys(this.fileMap).find((fsPath) => path.relative(doc.uri.fsPath, fsPath) === '');
            if (!this.ignoreSave && filePath) {
                actionContext.suppressTelemetry = false;
                const context = this.fileMap[filePath][1];
                const showSaveWarning = vscode.workspace.getConfiguration().get(this.showSavePromptKey);
                if (showSaveWarning) {
                    const message = yield this.getSaveConfirmationText(context);
                    const result = yield vscode.window.showWarningMessage(message, DialogResponses_1.DialogResponses.upload, DialogResponses_1.DialogResponses.alwaysUpload, DialogResponses_1.DialogResponses.dontUpload);
                    if (result === DialogResponses_1.DialogResponses.alwaysUpload) {
                        yield vscode.workspace.getConfiguration().update(this.showSavePromptKey, false, vscode.ConfigurationTarget.Global);
                        yield globalState.update(this.showSavePromptKey, true);
                    }
                    else if (result === DialogResponses_1.DialogResponses.dontUpload) {
                        throw new errors_1.UserCancelledError();
                    }
                }
                yield this.updateRemote(context, doc);
            }
        });
    }
    appendLineToOutput(value) {
        extensionVariables_1.ext.outputChannel.appendLine(value);
        extensionVariables_1.ext.outputChannel.show(true);
    }
    updateRemote(context, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            const filename = yield this.getFilename(context);
            this.appendLineToOutput(localize_1.localize('updating', 'Updating "{0}" ...', filename));
            const updatedData = yield this.updateData(context, doc.getText());
            this.appendLineToOutput(localize_1.localize('done', 'Updated "{0}".', filename));
            yield this.updateEditor(updatedData, vscode.window.activeTextEditor);
        });
    }
    updateEditor(data, textEditor) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!!textEditor) {
                yield BaseEditor.writeToEditor(textEditor, data);
                this.ignoreSave = true;
                try {
                    yield textEditor.document.save();
                }
                finally {
                    this.ignoreSave = false;
                }
            }
        });
    }
    // tslint:disable-next-line:member-ordering
    static writeToEditor(editor, data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield editor.edit((editBuilder) => {
                if (editor.document.lineCount > 0) {
                    const lastLine = editor.document.lineAt(editor.document.lineCount - 1);
                    editBuilder.delete(new vscode.Range(new vscode.Position(0, 0), new vscode.Position(lastLine.range.start.line, lastLine.range.end.character)));
                }
                editBuilder.insert(new vscode.Position(0, 0), data);
            });
        });
    }
}
exports.BaseEditor = BaseEditor;
//# sourceMappingURL=BaseEditor.js.map