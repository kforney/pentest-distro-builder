"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const extensionVariables_1 = require("../extensionVariables");
const localize_1 = require("../localize");
const AzureNode_1 = require("./AzureNode");
const CreatingTreeItem_1 = require("./CreatingTreeItem");
const LoadMoreTreeItem_1 = require("./LoadMoreTreeItem");
class AzureParentNode extends AzureNode_1.AzureNode {
    constructor(parent, treeItem, onNodeCreateEmitter) {
        super(parent, treeItem);
        this._cachedChildren = [];
        this._creatingNodes = [];
        this._clearCache = true;
        this._onNodeCreateEmitter = onNodeCreateEmitter;
    }
    getCachedChildren() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._clearCache) {
                this._initChildrenTask = this.loadMoreChildren();
            }
            if (this._initChildrenTask) {
                yield this._initChildrenTask;
            }
            return this._cachedChildren;
        });
    }
    get creatingNodes() {
        return this._creatingNodes;
    }
    clearCache() {
        this._clearCache = true;
    }
    createChild(userOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.treeItem.createChild) {
                let creatingNode;
                try {
                    const newTreeItem = yield this.treeItem.createChild(this, (label) => {
                        creatingNode = new AzureNode_1.AzureNode(this, new CreatingTreeItem_1.CreatingTreeItem(label));
                        this._creatingNodes.push(creatingNode);
                        //tslint:disable-next-line:no-floating-promises
                        this.treeDataProvider.refresh(this, false);
                    }, userOptions);
                    const newNode = this.createNewNode(newTreeItem);
                    yield this.addNodeToCache(newNode);
                    this._onNodeCreateEmitter.fire(newNode);
                    return newNode;
                }
                finally {
                    if (creatingNode) {
                        this._creatingNodes.splice(this._creatingNodes.indexOf(creatingNode), 1);
                        yield this.treeDataProvider.refresh(this, false);
                    }
                }
            }
            else {
                throw new errors_1.NotImplementedError('createChild', this.treeItem);
            }
        });
    }
    pickChildNode(expectedContextValues) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.treeItem.pickTreeItem) {
                const children = yield this.getCachedChildren();
                for (const val of expectedContextValues) {
                    const pickedItem = this.treeItem.pickTreeItem(val);
                    if (pickedItem) {
                        const node = children.find((n) => {
                            return (!!pickedItem.id && n.treeItem.id === pickedItem.id) || (n.treeItem.label === pickedItem.label);
                        });
                        if (node) {
                            return node;
                        }
                    }
                }
            }
            const options = {
                placeHolder: localize_1.localize('selectNode', 'Select {0}', this.treeItem.childTypeLabel)
            };
            const getNode = (yield extensionVariables_1.ext.ui.showQuickPick(this.getQuickPicks(expectedContextValues), options)).data;
            return yield getNode();
        });
    }
    addNodeToCache(node) {
        return __awaiter(this, void 0, void 0, function* () {
            // set index to the last element by default
            let index = this._cachedChildren.length;
            // tslint:disable-next-line:no-increment-decrement
            for (let i = 0; i < this._cachedChildren.length; i++) {
                if (node.treeItem.label.localeCompare(this._cachedChildren[i].treeItem.label) < 1) {
                    index = i;
                    break;
                }
            }
            this._cachedChildren.splice(index, 0, node);
            yield this.treeDataProvider.refresh(this, false);
        });
    }
    removeNodeFromCache(node) {
        return __awaiter(this, void 0, void 0, function* () {
            const index = this._cachedChildren.indexOf(node);
            if (index !== -1) {
                this._cachedChildren.splice(index, 1);
                yield this.treeDataProvider.refresh(this, false);
            }
        });
    }
    loadMoreChildren() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._loadMoreChildrenTask) {
                yield this._loadMoreChildrenTask;
            }
            else {
                this._loadMoreChildrenTask = this.loadMoreChildrenInternal();
                try {
                    yield this._loadMoreChildrenTask;
                }
                finally {
                    this._loadMoreChildrenTask = undefined;
                }
            }
        });
    }
    loadMoreChildrenInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._clearCache) {
                this._cachedChildren = [];
            }
            const sortCallback = this.treeItem.compareChildren
                ? this.treeItem.compareChildren
                : (n1, n2) => n1.treeItem.label.localeCompare(n2.treeItem.label);
            const newTreeItems = yield this.treeItem.loadMoreChildren(this, this._clearCache);
            this._cachedChildren = this._cachedChildren
                .concat(newTreeItems.map((t) => this.createNewNode(t)))
                .sort(sortCallback);
            this._clearCache = false;
        });
    }
    getQuickPicks(expectedContextValues) {
        return __awaiter(this, void 0, void 0, function* () {
            let nodes = yield this.getCachedChildren();
            nodes = nodes.filter((node) => node.includeInNodePicker(expectedContextValues));
            const picks = nodes.map((n) => {
                return {
                    label: n.treeItem.label,
                    description: n.treeItem.description,
                    id: n.id,
                    data: () => __awaiter(this, void 0, void 0, function* () { return yield Promise.resolve(n); })
                };
            });
            if (this.treeItem.createChild && this.treeItem.childTypeLabel) {
                picks.unshift({
                    label: localize_1.localize('nodePickerCreateNew', '$(plus) Create New {0}', this.treeItem.childTypeLabel),
                    description: '',
                    data: () => __awaiter(this, void 0, void 0, function* () { return yield this.createChild(); })
                });
            }
            if (this.treeItem.hasMoreChildren()) {
                picks.push({
                    label: LoadMoreTreeItem_1.LoadMoreTreeItem.label,
                    description: '',
                    data: () => __awaiter(this, void 0, void 0, function* () {
                        yield this.loadMoreChildren();
                        yield this.treeDataProvider.refresh(this, false);
                        return this;
                    })
                });
            }
            return picks;
        });
    }
    createNewNode(treeItem) {
        const parentTreeItem = treeItem;
        // tslint:disable-next-line:strict-boolean-expressions
        if (parentTreeItem.loadMoreChildren) {
            return new AzureParentNode(this, parentTreeItem, this._onNodeCreateEmitter);
        }
        else {
            return new AzureNode_1.AzureNode(this, treeItem);
        }
    }
}
exports.AzureParentNode = AzureParentNode;
//# sourceMappingURL=AzureParentNode.js.map