/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const vscode_languageserver_1 = require("vscode-languageserver");
const dockerfile_utils_1 = require("dockerfile-utils");
const dockerfile_language_service_1 = require("dockerfile-language-service");
/**
 * The settings to use for the validator if the client doesn't support
 * workspace/configuration requests.
 */
let validatorSettings = null;
/**
 * The validator settings that correspond to an individual file retrieved via
 * the workspace/configuration request.
 */
let validatorConfigurations = new Map();
let connection = vscode_languageserver_1.createConnection();
let service = dockerfile_language_service_1.DockerfileLanguageServiceFactory.createLanguageService();
service.setLogger({
    log(message) {
        connection.console.log(message);
    }
});
/**
 * Whether the client supports the workspace/applyEdit request.
 */
let applyEditSupport = false;
/**
 * Whether the client supports the workspace/configuration request.
 */
let configurationSupport = false;
let documentChangesSupport = false;
let codeActionQuickFixSupport = false;
let documents = {};
/**
 * Retrieves a text document for the file located at the given URI
 * string.
 *
 * @param uri the URI of the interested file, must be defined and not
 *            null
 * @return the text document for the file, or null if no file exists
 *         at the given location
 */
function getDocument(uri) {
    if (documents[uri]) {
        return Promise.resolve(documents[uri]);
    }
    return new Promise((resolve, reject) => {
        let file = vscode_languageserver_1.Files.uriToFilePath(uri);
        fs.exists(file, (exists) => {
            if (exists) {
                fs.readFile(file, (err, data) => {
                    resolve(vscode_languageserver_1.TextDocument.create(uri, "dockerfile", 1, data.toString()));
                });
            }
            else {
                resolve(null);
            }
        });
    });
}
function supportsDeprecatedItems(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.completion
        && capabilities.textDocument.completion.completionItem
        && capabilities.textDocument.completion.completionItem.deprecatedSupport;
}
function supportsSnippets(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.completion
        && capabilities.textDocument.completion.completionItem
        && capabilities.textDocument.completion.completionItem.snippetSupport;
}
function supportsCodeActionQuickFixes(capabilities) {
    let values = capabilities.textDocument
        && capabilities.textDocument.codeAction
        && capabilities.textDocument.codeAction.codeActionLiteralSupport
        && capabilities.textDocument.codeAction.codeActionLiteralSupport.codeActionKind
        && capabilities.textDocument.codeAction.codeActionLiteralSupport.codeActionKind.valueSet;
    if (values === null || values === undefined) {
        return false;
    }
    for (let value of values) {
        if (value === vscode_languageserver_1.CodeActionKind.QuickFix) {
            return true;
        }
    }
    return false;
}
/**
 * Gets the MarkupKind[] that the client supports for the
 * documentation field of a CompletionItem.
 *
 * @return the supported MarkupKind[], may be null or undefined
 */
function getCompletionItemDocumentationFormat(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.completion
        && capabilities.textDocument.completion.completionItem
        && capabilities.textDocument.completion.completionItem.documentationFormat;
}
function getHoverContentFormat(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.hover
        && capabilities.textDocument.hover.contentFormat;
}
function getLineFoldingOnly(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.foldingRange
        && capabilities.textDocument.foldingRange.lineFoldingOnly;
}
function getRangeLimit(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.foldingRange
        && capabilities.textDocument.foldingRange.rangeLimit;
}
function setServiceCapabilities(capabilities) {
    service.setCapabilities({
        completion: {
            completionItem: {
                deprecatedSupport: supportsDeprecatedItems(capabilities),
                documentationFormat: getCompletionItemDocumentationFormat(capabilities),
                snippetSupport: supportsSnippets(capabilities)
            }
        },
        hover: {
            contentFormat: getHoverContentFormat(capabilities)
        },
        foldingRange: {
            lineFoldingOnly: getLineFoldingOnly(capabilities),
            rangeLimit: getRangeLimit(capabilities)
        }
    });
}
connection.onInitialized(() => {
    if (configurationSupport) {
        // listen for notification changes if the client supports workspace/configuration
        connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type);
    }
});
connection.onInitialize((params) => {
    setServiceCapabilities(params.capabilities);
    applyEditSupport = params.capabilities.workspace && params.capabilities.workspace.applyEdit === true;
    documentChangesSupport = params.capabilities.workspace && params.capabilities.workspace.workspaceEdit && params.capabilities.workspace.workspaceEdit.documentChanges === true;
    configurationSupport = params.capabilities.workspace && params.capabilities.workspace.configuration === true;
    codeActionQuickFixSupport = supportsCodeActionQuickFixes(params.capabilities);
    return {
        capabilities: {
            textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
            codeActionProvider: applyEditSupport,
            completionProvider: {
                resolveProvider: true,
                triggerCharacters: [
                    '=',
                    ' ',
                    '$',
                    '-',
                ]
            },
            executeCommandProvider: applyEditSupport ? {
                commands: [
                    dockerfile_language_service_1.CommandIds.LOWERCASE,
                    dockerfile_language_service_1.CommandIds.UPPERCASE,
                    dockerfile_language_service_1.CommandIds.EXTRA_ARGUMENT,
                    dockerfile_language_service_1.CommandIds.DIRECTIVE_TO_BACKSLASH,
                    dockerfile_language_service_1.CommandIds.DIRECTIVE_TO_BACKTICK,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_CHOWN,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_COPY_FROM,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_HEALTHCHECK_INTERVAL,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_HEALTHCHECK_RETRIES,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_HEALTHCHECK_START_PERIOD,
                    dockerfile_language_service_1.CommandIds.FLAG_TO_HEALTHCHECK_TIMEOUT,
                    dockerfile_language_service_1.CommandIds.CONVERT_TO_AS,
                    dockerfile_language_service_1.CommandIds.REMOVE_EMPTY_CONTINUATION_LINE
                ]
            } : undefined,
            documentFormattingProvider: true,
            documentRangeFormattingProvider: true,
            documentOnTypeFormattingProvider: {
                firstTriggerCharacter: '\\',
                moreTriggerCharacter: ['`']
            },
            hoverProvider: true,
            documentSymbolProvider: true,
            documentHighlightProvider: true,
            renameProvider: true,
            definitionProvider: true,
            signatureHelpProvider: {
                triggerCharacters: [
                    '-',
                    '[',
                    ',',
                    ' ',
                    '='
                ]
            },
            documentLinkProvider: {
                resolveProvider: true
            },
            foldingRangeProvider: true
        }
    };
});
function convertValidatorConfiguration(config) {
    let deprecatedMaintainer = dockerfile_utils_1.ValidationSeverity.WARNING;
    let directiveCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
    let emptyContinuationLine = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionCmdMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionEntrypointMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionHealthcheckMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionJSONInSingleQuotes = dockerfile_utils_1.ValidationSeverity.WARNING;
    let instructionWorkdirRelative = dockerfile_utils_1.ValidationSeverity.WARNING;
    if (config) {
        deprecatedMaintainer = getSeverity(config.deprecatedMaintainer);
        directiveCasing = getSeverity(config.directiveCasing);
        emptyContinuationLine = getSeverity(config.emptyContinuationLine);
        instructionCasing = getSeverity(config.instructionCasing);
        instructionCmdMultiple = getSeverity(config.instructionCmdMultiple);
        instructionEntrypointMultiple = getSeverity(config.instructionEntrypointMultiple);
        instructionHealthcheckMultiple = getSeverity(config.instructionHealthcheckMultiple);
        instructionJSONInSingleQuotes = getSeverity(config.instructionJSONInSingleQuotes);
        instructionWorkdirRelative = getSeverity(config.instructionWorkdirRelative);
    }
    return {
        deprecatedMaintainer,
        directiveCasing,
        emptyContinuationLine,
        instructionCasing,
        instructionCmdMultiple,
        instructionEntrypointMultiple,
        instructionHealthcheckMultiple,
        instructionJSONInSingleQuotes,
        instructionWorkdirRelative
    };
}
function validateTextDocument(textDocument) {
    if (configurationSupport) {
        getConfiguration(textDocument.uri).then((config) => {
            const fileSettings = convertValidatorConfiguration(config);
            const diagnostics = service.validate(textDocument.getText(), fileSettings);
            connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
        });
    }
    else {
        const diagnostics = service.validate(textDocument.getText(), validatorSettings);
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
    }
}
function getSeverity(severity) {
    switch (severity) {
        case "ignore":
            return dockerfile_utils_1.ValidationSeverity.IGNORE;
        case "warning":
            return dockerfile_utils_1.ValidationSeverity.WARNING;
        case "error":
            return dockerfile_utils_1.ValidationSeverity.ERROR;
    }
    return null;
}
/**
 * Gets the validation configuration that pertains to the specified resource.
 *
 * @param resource the interested resource
 * @return the configuration to use to validate the interested resource
 */
function getConfiguration(resource) {
    let result = validatorConfigurations.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({ section: "docker.languageserver.diagnostics", scopeUri: resource });
        validatorConfigurations.set(resource, result);
    }
    return result;
}
// listen for notifications when the client's configuration has changed
connection.onNotification(vscode_languageserver_1.DidChangeConfigurationNotification.type, () => {
    refreshConfigurations();
});
/**
 * Wipes and reloads the internal cache of validator configurations.
 */
function refreshConfigurations() {
    // store all the URIs that need to be refreshed
    const settingsRequest = [];
    for (let uri in documents) {
        settingsRequest.push({ section: "docker.languageserver.diagnostics", scopeUri: uri });
    }
    // clear the cache
    validatorConfigurations.clear();
    // ask the workspace for the configurations
    connection.workspace.getConfiguration(settingsRequest).then((values) => {
        const toRevalidate = [];
        for (let i = 0; i < values.length; i++) {
            const resource = settingsRequest[i].scopeUri;
            // a value might have been stored already, use it instead and ignore this one if so
            if (values[i] && !validatorConfigurations.has(resource)) {
                validatorConfigurations.set(resource, Promise.resolve(values[i]));
                toRevalidate.push(resource);
            }
        }
        for (const resource of toRevalidate) {
            validateTextDocument(documents[resource]);
        }
    });
}
connection.onDidChangeConfiguration((change) => {
    if (configurationSupport) {
        refreshConfigurations();
    }
    else {
        let settings = change.settings;
        if (settings.docker && settings.docker.languageserver && settings.docker.languageserver.diagnostics) {
            validatorSettings = convertValidatorConfiguration(settings.docker.languageserver.diagnostics);
        }
        else {
            validatorSettings = convertValidatorConfiguration(null);
        }
        // validate all the documents again
        Object.keys(documents).forEach((key) => {
            validateTextDocument(documents[key]);
        });
    }
});
connection.onCompletion((textDocumentPosition) => {
    return getDocument(textDocumentPosition.textDocument.uri).then((document) => {
        if (document) {
            return service.computeCompletionItems(document.getText(), textDocumentPosition.position);
        }
        return null;
    });
});
connection.onSignatureHelp((textDocumentPosition) => {
    return getDocument(textDocumentPosition.textDocument.uri).then((document) => {
        if (document !== null) {
            return service.computeSignatureHelp(document.getText(), textDocumentPosition.position);
        }
        return {
            signatures: [],
            activeSignature: null,
            activeParameter: null,
        };
    });
});
connection.onCompletionResolve((item) => {
    return service.resolveCompletionItem(item);
});
connection.onHover((textDocumentPosition) => {
    return getDocument(textDocumentPosition.textDocument.uri).then((document) => {
        if (document) {
            return service.computeHover(document.getText(), textDocumentPosition.position);
        }
        return null;
    });
});
connection.onDocumentHighlight((textDocumentPosition) => {
    return getDocument(textDocumentPosition.textDocument.uri).then((document) => {
        if (document) {
            return service.computeHighlightRanges(document.getText(), textDocumentPosition.position);
        }
        return [];
    });
});
connection.onCodeAction((codeActionParams) => {
    if (applyEditSupport && codeActionParams.context.diagnostics.length > 0) {
        let commands = service.computeCodeActions(codeActionParams.textDocument, codeActionParams.range, codeActionParams.context);
        if (codeActionQuickFixSupport) {
            return getDocument(codeActionParams.textDocument.uri).then((document) => {
                let codeActions = [];
                for (let command of commands) {
                    let codeAction = {
                        title: command.title,
                        kind: vscode_languageserver_1.CodeActionKind.QuickFix
                    };
                    let edit = computeWorkspaceEdit(codeActionParams.textDocument.uri, document, command.command, command.arguments);
                    if (edit) {
                        codeAction.edit = edit;
                    }
                    codeActions.push(codeAction);
                }
                return codeActions;
            });
        }
        return commands;
    }
    return [];
});
function computeWorkspaceEdit(uri, document, command, args) {
    let edits = service.computeCommandEdits(document.getText(), command, args);
    if (edits) {
        if (documentChangesSupport) {
            let identifier = vscode_languageserver_1.VersionedTextDocumentIdentifier.create(uri, document.version);
            return {
                documentChanges: [
                    vscode_languageserver_1.TextDocumentEdit.create(identifier, edits)
                ]
            };
        }
        else {
            return {
                changes: {
                    [uri]: edits
                }
            };
        }
    }
    return null;
}
connection.onExecuteCommand((params) => {
    if (applyEditSupport) {
        let uri = params.arguments[0];
        getDocument(uri).then((document) => {
            if (document) {
                let workspaceEdit = computeWorkspaceEdit(uri, document, params.command, params.arguments);
                if (workspaceEdit) {
                    connection.workspace.applyEdit(workspaceEdit);
                }
            }
            return null;
        });
    }
});
connection.onDefinition((textDocumentPosition) => {
    return getDocument(textDocumentPosition.textDocument.uri).then((document) => {
        if (document) {
            return service.computeDefinition(textDocumentPosition.textDocument, document.getText(), textDocumentPosition.position);
        }
        return null;
    });
});
connection.onRenameRequest((params) => {
    return getDocument(params.textDocument.uri).then((document) => {
        if (document) {
            let edits = service.computeRename(params.textDocument, document.getText(), params.position, params.newName);
            return {
                changes: {
                    [params.textDocument.uri]: edits
                }
            };
        }
        return null;
    });
});
connection.onDocumentSymbol((documentSymbolParams) => {
    return getDocument(documentSymbolParams.textDocument.uri).then((document) => {
        if (document) {
            return service.computeSymbols(documentSymbolParams.textDocument, document.getText());
        }
        return [];
    });
});
connection.onDocumentFormatting((documentFormattingParams) => {
    return getDocument(documentFormattingParams.textDocument.uri).then((document) => {
        if (document) {
            return service.format(document.getText(), documentFormattingParams.options);
        }
        return [];
    });
});
connection.onDocumentRangeFormatting((rangeFormattingParams) => {
    return getDocument(rangeFormattingParams.textDocument.uri).then((document) => {
        if (document) {
            return service.formatRange(document.getText(), rangeFormattingParams.range, rangeFormattingParams.options);
        }
        return [];
    });
});
connection.onDocumentOnTypeFormatting((onTypeFormattingParams) => {
    return getDocument(onTypeFormattingParams.textDocument.uri).then((document) => {
        if (document) {
            return service.formatOnType(document.getText(), onTypeFormattingParams.position, onTypeFormattingParams.ch, onTypeFormattingParams.options);
        }
        return [];
    });
});
connection.onDocumentLinks((documentLinkParams) => {
    return getDocument(documentLinkParams.textDocument.uri).then((document) => {
        if (document) {
            return service.computeLinks(document.getText());
        }
        return [];
    });
});
connection.onDocumentLinkResolve((documentLink) => {
    return service.resolveLink(documentLink);
});
connection.onFoldingRanges((foldingRangeParams) => {
    return getDocument(foldingRangeParams.textDocument.uri).then((document) => {
        if (document) {
            return service.computeFoldingRanges(document.getText());
        }
        return [];
    });
});
connection.onDidOpenTextDocument((didOpenTextDocumentParams) => {
    let document = vscode_languageserver_1.TextDocument.create(didOpenTextDocumentParams.textDocument.uri, didOpenTextDocumentParams.textDocument.languageId, didOpenTextDocumentParams.textDocument.version, didOpenTextDocumentParams.textDocument.text);
    documents[didOpenTextDocumentParams.textDocument.uri] = document;
    validateTextDocument(document);
});
connection.onDidChangeTextDocument((didChangeTextDocumentParams) => {
    let document = documents[didChangeTextDocumentParams.textDocument.uri];
    let buffer = document.getText();
    let content = buffer;
    let changes = didChangeTextDocumentParams.contentChanges;
    for (let i = 0; i < changes.length; i++) {
        if (!changes[i].range && !changes[i].rangeLength) {
            // no ranges defined, the text is the entire document then
            buffer = changes[i].text;
            break;
        }
        let offset = document.offsetAt(changes[i].range.start);
        let end = null;
        if (changes[i].range.end) {
            end = document.offsetAt(changes[i].range.end);
        }
        else {
            end = offset + changes[i].rangeLength;
        }
        buffer = buffer.substring(0, offset) + changes[i].text + buffer.substring(end);
    }
    document = vscode_languageserver_1.TextDocument.create(didChangeTextDocumentParams.textDocument.uri, document.languageId, didChangeTextDocumentParams.textDocument.version, buffer);
    documents[didChangeTextDocumentParams.textDocument.uri] = document;
    if (content !== buffer) {
        validateTextDocument(document);
    }
});
connection.onDidCloseTextDocument((didCloseTextDocumentParams) => {
    validatorConfigurations.delete(didCloseTextDocumentParams.textDocument.uri);
    connection.sendDiagnostics({ uri: didCloseTextDocumentParams.textDocument.uri, diagnostics: [] });
    delete documents[didCloseTextDocumentParams.textDocument.uri];
});
// setup complete, start listening for a client connection
connection.listen();
