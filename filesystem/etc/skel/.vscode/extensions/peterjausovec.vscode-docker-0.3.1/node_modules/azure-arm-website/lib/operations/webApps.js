/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * @summary Get all apps for a subscription.
 *
 * Get all apps for a subscription.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.Web/sites';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all web, mobile, and API apps in the specified resource group.
 *
 * Gets all web, mobile, and API apps in the specified resource group.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeSlots] Specify <strong>true</strong> to
 * include deployment slots in results. The default is false, which only gives
 * you the production slot of all apps.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByResourceGroup(resourceGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeSlots = (options && options.includeSlots !== undefined) ? options.includeSlots : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (includeSlots !== null && includeSlots !== undefined && typeof includeSlots !== 'boolean') {
      throw new Error('includeSlots must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (includeSlots !== null && includeSlots !== undefined) {
    queryParameters.push('includeSlots=' + encodeURIComponent(includeSlots.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of a web, mobile, or API app.
 *
 * Gets the details of a web, mobile, or API app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
 * enabled; otherwise, <code>false</code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
 * otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * <code>true</code> if request tracing is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * <code>true</code> if remote debugging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * <code>true</code> if detailed error logging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * <code>true</code> to use 32-bit worker process; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
 * Always On is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
 * if Auto Heal is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
 * default is <code>false</code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
 * enable client affinity; <code>false</code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is <code>true</code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, <code>false</code>. Default is <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
 * disable the public hostnames of the app; otherwise, <code>false</code>.
 * If <code>true</code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
 * overwrite destination app; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * <code>true</code> to clone custom hostnames from source app; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * <code>true</code> to clone source control from source app; otherwise,
 * <code>false</code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * <code>true</code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdate(resourceGroupName, name, siteEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app to delete.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
 * deleted
 *
 * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
 * Service plan will be empty after app deletion and you want to delete the
 * empty App Service plan. By default, the empty App Service plan is not
 * deleted.
 *
 * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
 * skipped
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let deleteMetrics = (options && options.deleteMetrics !== undefined) ? options.deleteMetrics : undefined;
  let deleteEmptyServerFarm = (options && options.deleteEmptyServerFarm !== undefined) ? options.deleteEmptyServerFarm : undefined;
  let skipDnsRegistration = (options && options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (deleteMetrics !== null && deleteMetrics !== undefined && typeof deleteMetrics !== 'boolean') {
      throw new Error('deleteMetrics must be of type boolean.');
    }
    if (deleteEmptyServerFarm !== null && deleteEmptyServerFarm !== undefined && typeof deleteEmptyServerFarm !== 'boolean') {
      throw new Error('deleteEmptyServerFarm must be of type boolean.');
    }
    if (skipDnsRegistration !== null && skipDnsRegistration !== undefined && typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (deleteMetrics !== null && deleteMetrics !== undefined) {
    queryParameters.push('deleteMetrics=' + encodeURIComponent(deleteMetrics.toString()));
  }
  if (deleteEmptyServerFarm !== null && deleteEmptyServerFarm !== undefined) {
    queryParameters.push('deleteEmptyServerFarm=' + encodeURIComponent(deleteEmptyServerFarm.toString()));
  }
  if (skipDnsRegistration !== null && skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Analyze a custom hostname.
 *
 * Analyze a custom hostname.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.hostName] Custom hostname
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CustomHostnameAnalysisResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _analyzeCustomHostname(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let hostName = (options && options.hostName !== undefined) ? options.hostName : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName !== null && hostName !== undefined && typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (hostName !== null && hostName !== undefined) {
    queryParameters.push('hostName=' + encodeURIComponent(hostName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CustomHostnameAnalysisResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Applies the configuration settings from the target slot onto the
 * current slot.
 *
 * Applies the configuration settings from the target slot onto the current
 * slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a backup of an app.
 *
 * Creates a backup of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Backup configuration. You can use the JSON response
 * from the POST action as input here.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backup(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackups(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Discovers an existing app backup that can be restored from a blob
 * in Azure storage.
 *
 * Discovers an existing app backup that can be restored from a blob in Azure
 * storage.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request A RestoreRequest object that includes Azure storage
 * URL and blog name for discovery of backup.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _discoverRestore(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a backup of an app by its ID.
 *
 * Gets a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupStatus(resourceGroupName, name, backupId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a backup of an app by its ID.
 *
 * Deletes a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackup(resourceGroupName, name, backupId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets status of a web app backup that may be in progress, including
 * secrets associated with the backup, such as the Azure Storage SAS URL. Also
 * can be used to update the SAS URL for the backup if a new URL is passed in
 * the request body.
 *
 * Gets status of a web app backup that may be in progress, including secrets
 * associated with the backup, such as the Azure Storage SAS URL. Also can be
 * used to update the SAS URL for the backup if a new URL is passed in the
 * request body.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} backupId Id of backup
 *
 * @param {object} request Information on backup request
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restore(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRestore(resourceGroupName, name, backupId, request, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Replaces the application settings of an app.
 *
 * Replaces the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} appSettings Application settings of the app.
 *
 * @param {object} [appSettings.properties] Settings.
 *
 * @param {string} [appSettings.name] Resource Name.
 *
 * @param {string} [appSettings.kind] Kind of resource.
 *
 * @param {string} appSettings.location Resource Location.
 *
 * @param {string} [appSettings.type] Resource type.
 *
 * @param {object} [appSettings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationSettings(resourceGroupName, name, appSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (appSettings === null || appSettings === undefined) {
      throw new Error('appSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (appSettings !== null && appSettings !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, appSettings, 'appSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(appSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the application settings of an app.
 *
 * Gets the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listApplicationSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the Authentication / Authorization settings associated with
 * web app.
 *
 * Updates the Authentication / Authorization settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} siteAuthSettings Auth settings associated with web app
 *
 * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
 * Authentication / Authorization feature is enabled for the current app;
 * otherwise, <code>false</code>.
 *
 * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
 * Authentication / Authorization feature in use for the current app.
 * The setting in this value can control the behavior of certain features in
 * the Authentication / Authorization module.
 *
 * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
 * take when an unauthenticated client attempts to access the app. Possible
 * values include: 'RedirectToLoginPage', 'AllowAnonymous'
 *
 * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
 * durably store platform-specific security tokens that are obtained during
 * login flows; otherwise, <code>false</code>.
 * The default is <code>false</code>.
 *
 * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
 * that can be redirected to as part of logging in or logging out of the app.
 * Note that the query string part of the URL is ignored.
 * This is an advanced setting typically only needed by Windows Store
 * application backends.
 * Note that URLs within the current domain are always implicitly allowed.
 *
 * @param {string} [siteAuthSettings.defaultProvider] The default
 * authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the
 * unauthenticated client
 * action is set to "RedirectToLoginPage". Possible values include:
 * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
 *
 * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
 * hours after session token expiration that a session token can be used to
 * call the token refresh API. The default is 72 hours.
 *
 * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
 * party application, known as the client_id.
 * This setting is required for enabling OpenID Connection authentication with
 * Azure Active Directory or
 * other 3rd party OpenID Connect providers.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
 * relying party application (in Azure Active Directory, this is also referred
 * to as the Key).
 * This setting is optional. If no client secret is configured, the OpenID
 * Connect implicit auth flow is used to authenticate end users.
 * Otherwise, the OpenID Connect Authorization Code Flow is used to
 * authenticate end users.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
 * represents the entity which issues access tokens for this application.
 * When using Azure Active Directory, this value is the URI of the directory
 * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
 * This URI is a case-sensitive identifier for the token issuer.
 * More information on OpenID Connect Discovery:
 * http://openid.net/specs/openid-connect-discovery-1_0.html
 *
 * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
 * to consider when validating JWTs issued by
 * Azure Active Directory. Note that the <code>ClientID</code> value is always
 * considered an
 * allowed audience, regardless of this setting.
 *
 * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
 * send to the OpenID Connect authorization endpoint when
 * a user logs in. Each parameter must be in the form "key=value".
 *
 * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
 * ID for the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.googleClientSecret] The client secret
 * associated with the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Google Sign-In authentication.
 * This setting is optional. If not specified, "openid", "profile", and "email"
 * are used as default scopes.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
 * app used for login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
 * Facebook app used for Facebook Login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Facebook Login authentication.
 * This setting is optional.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
 * consumer key of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
 * consumer secret of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
 * client ID that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
 * 2.0 client secret that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
 * scopes that will be requested as part of Microsoft Account authentication.
 * This setting is optional. If not specified, "wl.basic" is used as the
 * default scope.
 * Microsoft Account Scopes and permissions documentation:
 * https://msdn.microsoft.com/en-us/library/dn631845.aspx
 *
 * @param {string} [siteAuthSettings.name] Resource Name.
 *
 * @param {string} [siteAuthSettings.kind] Kind of resource.
 *
 * @param {string} siteAuthSettings.location Resource Location.
 *
 * @param {string} [siteAuthSettings.type] Resource type.
 *
 * @param {object} [siteAuthSettings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteAuthSettings === null || siteAuthSettings === undefined) {
      throw new Error('siteAuthSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteAuthSettings !== null && siteAuthSettings !== undefined) {
      let requestModelMapper = new client.models['SiteAuthSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, siteAuthSettings, 'siteAuthSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteAuthSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Authentication/Authorization settings of an app.
 *
 * Gets the Authentication/Authorization settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAuthSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the backup configuration of an app.
 *
 * Updates the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Edited backup configuration.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateBackupConfiguration(resourceGroupName, name, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the backup configuration of an app.
 *
 * Deletes the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the backup configuration of an app.
 *
 * Gets the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the connection strings of an app.
 *
 * Replaces the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} connectionStrings Connection strings of the app or
 * deployment slot. See example.
 *
 * @param {object} [connectionStrings.properties] Connection strings.
 *
 * @param {string} [connectionStrings.name] Resource Name.
 *
 * @param {string} [connectionStrings.kind] Kind of resource.
 *
 * @param {string} connectionStrings.location Resource Location.
 *
 * @param {string} [connectionStrings.type] Resource type.
 *
 * @param {object} [connectionStrings.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConnectionStrings(resourceGroupName, name, connectionStrings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (connectionStrings === null || connectionStrings === undefined) {
      throw new Error('connectionStrings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionStrings !== null && connectionStrings !== undefined) {
      let requestModelMapper = new client.models['ConnectionStringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionStrings, 'connectionStrings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionStrings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the connection strings of an app.
 *
 * Gets the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConnectionStrings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the logging configuration of an app.
 *
 * Gets the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDiagnosticLogsConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the logging configuration of an app.
 *
 * Updates the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
 * the logging configuration to change in the "properties" property.
 *
 * @param {object} [siteLogsConfig.applicationLogs] Application logs
 * configuration.
 *
 * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
 * to file system configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
 * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
 * Application logs to azure table storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
 * URL to an Azure table with add/query/delete permissions.
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
 * Application logs to blob storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
 * url to a azure blob container with read/write/list/delete permissions.
 *
 * @param {number}
 * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
 * in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
 *
 * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
 * system configuration.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
 * size in megabytes that http log files can use.
 * When reached old log files will be removed to make space for new ones.
 * Value can range between 25 and 100.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
 * Retention in days.
 * Remove files older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
 * azure blob storage configuration.
 *
 * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
 * a azure blob container with read/write/list/delete permissions.
 *
 * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
 * Retention in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
 * tracing configuration.
 *
 * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
 * messages configuration.
 *
 * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
 *
 * @param {string} [siteLogsConfig.name] Resource Name.
 *
 * @param {string} [siteLogsConfig.kind] Kind of resource.
 *
 * @param {string} siteLogsConfig.location Resource Location.
 *
 * @param {string} [siteLogsConfig.type] Resource type.
 *
 * @param {object} [siteLogsConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteLogsConfig === null || siteLogsConfig === undefined) {
      throw new Error('siteLogsConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteLogsConfig !== null && siteLogsConfig !== undefined) {
      let requestModelMapper = new client.models['SiteLogsConfig']().mapper();
      requestModel = client.serialize(requestModelMapper, siteLogsConfig, 'siteLogsConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteLogsConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the metadata of an app.
 *
 * Replaces the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} metadata Edited metadata of the app or deployment slot. See
 * example.
 *
 * @param {object} [metadata.properties] Settings.
 *
 * @param {string} [metadata.name] Resource Name.
 *
 * @param {string} [metadata.kind] Kind of resource.
 *
 * @param {string} metadata.location Resource Location.
 *
 * @param {string} [metadata.type] Resource type.
 *
 * @param {object} [metadata.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateMetadata(resourceGroupName, name, metadata, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (metadata === null || metadata === undefined) {
      throw new Error('metadata cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (metadata !== null && metadata !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, metadata, 'metadata');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(metadata, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the metadata of an app.
 *
 * Gets the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetadata(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingCredentials(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginListPublishingCredentials(resourceGroupName, name, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Updates the Push settings associated with web app.
 *
 * Updates the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} pushSettings Push settings associated with web app
 *
 * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
 * whether the Push endpoint is enabled.
 *
 * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
 * containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
 * containing a list of tags that require user authentication to be used in the
 * push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSitePushSettings(resourceGroupName, name, pushSettings, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (pushSettings === null || pushSettings === undefined) {
      throw new Error('pushSettings cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (pushSettings !== null && pushSettings !== undefined) {
      let requestModelMapper = new client.models['PushSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, pushSettings, 'pushSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(pushSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Push settings associated with web app.
 *
 * Gets the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSitePushSettings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the names of app settings and connection strings that stick to
 * the slot (not swapped).
 *
 * Gets the names of app settings and connection strings that stick to the slot
 * (not swapped).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotConfigNamesResource} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotConfigurationNames(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotConfigNamesResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the names of application settings and connection string
 * that remain with the slot during swap operation.
 *
 * Updates the names of application settings and connection string that remain
 * with the slot during swap operation.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotConfigNames Names of application settings and connection
 * strings. See example.
 *
 * @param {array} [slotConfigNames.connectionStringNames] List of connection
 * string names.
 *
 * @param {array} [slotConfigNames.appSettingNames] List of application
 * settings names.
 *
 * @param {string} [slotConfigNames.name] Resource Name.
 *
 * @param {string} [slotConfigNames.kind] Kind of resource.
 *
 * @param {string} slotConfigNames.location Resource Location.
 *
 * @param {string} [slotConfigNames.type] Resource type.
 *
 * @param {object} [slotConfigNames.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotConfigNamesResource} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotConfigNames === null || slotConfigNames === undefined) {
      throw new Error('slotConfigNames cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotConfigNames !== null && slotConfigNames !== undefined) {
      let requestModelMapper = new client.models['SlotConfigNamesResource']().mapper();
      requestModel = client.serialize(requestModelMapper, slotConfigNames, 'slotConfigNames');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotConfigNames, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotConfigNamesResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the configuration of an app, such as platform version and
 * bitness, default documents, virtual applications, Always On, etc.
 *
 * Gets the configuration of an app, such as platform version and bitness,
 * default documents, virtual applications, Always On, etc.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfiguration(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
 * request tracing is enabled; otherwise, <code>false</code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
 * remote debugging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
 * logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
 * if detailed error logging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
 * 32-bit worker process; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
 * WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
 * enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
 * is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
 * local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null && siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
 * request tracing is enabled; otherwise, <code>false</code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
 * remote debugging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
 * logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
 * if detailed error logging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
 * 32-bit worker process; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
 * WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
 * enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
 * is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
 * local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConfiguration(resourceGroupName, name, siteConfig, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null && siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of web app configuration snapshots identifiers. Each
 * element of the list contains a timestamp and the ID of the snapshot.
 *
 * Gets a list of web app configuration snapshots identifiers. Each element of
 * the list contains a timestamp and the ID of the snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConfigurationSnapshotInfo(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'SiteConfigurationSnapshotInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'SiteConfigurationSnapshotInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a snapshot of the configuration of an app at a previous point
 * in time.
 *
 * Gets a snapshot of the configuration of an app at a previous point in time.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Reverts the configuration of an app to a previous snapshot.
 *
 * Reverts the configuration of an app to a previous snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeployments(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeployment(resourceGroupName, name, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDeployment(resourceGroupName, name, id, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null && deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDeployment(resourceGroupName, name, id, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiers(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get domain ownership identifier for web app.
 *
 * Get domain ownership identifier for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null && domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a domain ownership identifier for a web app.
 *
 * Deletes a domain ownership identifier for a web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null && domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindings(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHostNameBinding(resourceGroupName, name, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a hostname binding for an app.
 *
 * Creates a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} hostNameBinding Binding details. This is the JSON
 * representation of a HostNameBinding object.
 *
 * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
 *
 * @param {string} [hostNameBinding.siteName] App Service app name.
 *
 * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
 * resource URI.
 *
 * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
 *
 * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
 * Possible values include: 'Website', 'TrafficManager'
 *
 * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
 * record type. Possible values include: 'CName', 'A'
 *
 * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
 * values include: 'Verified', 'Managed'
 *
 * @param {string} [hostNameBinding.sslState] SSL type. Possible values
 * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
 *
 * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
 *
 * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
 * the hostname if IP based SSL is enabled.
 *
 * @param {string} [hostNameBinding.name] Resource Name.
 *
 * @param {string} [hostNameBinding.kind] Kind of resource.
 *
 * @param {string} hostNameBinding.location Resource Location.
 *
 * @param {string} [hostNameBinding.type] Resource type.
 *
 * @param {object} [hostNameBinding.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (hostNameBinding === null || hostNameBinding === undefined) {
      throw new Error('hostNameBinding cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (hostNameBinding !== null && hostNameBinding !== undefined) {
      let requestModelMapper = new client.models['HostNameBinding']().mapper();
      requestModel = client.serialize(requestModelMapper, hostNameBinding, 'hostNameBinding');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(hostNameBinding, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a hostname binding for an app.
 *
 * Deletes a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHostNameBinding(resourceGroupName, name, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
 * App.
 *
 * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a Hybrid Connection from this site.
 *
 * Removes a Hybrid Connection from this site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the send key name and value for a Hybrid Connection.
 *
 * Gets the send key name and value for a Hybrid Connection.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnectionKey} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnectionKey']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets hybrid connections configured for an app (or deployment slot,
 * if specified).
 *
 * Gets hybrid connections configured for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listRelayServiceConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a hybrid connection configuration by its name.
 *
 * Gets a hybrid connection configuration by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRelayServiceConnection(resourceGroupName, name, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a relay service connection by its name.
 *
 * Deletes a relay service connection by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRelayServiceConnection(resourceGroupName, name, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiers(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} instanceId The ID of a specific scaled-out instance. This is
 * the value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeployments(resourceGroupName, name, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getInstanceDeployment(resourceGroupName, name, id, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null && deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteCloneability} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _isCloneable(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteCloneability']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitions(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.details] Specify "true" to include metric details
 * in the response. It is "false" by default.
 *
 * @param {string} [options.filter] Return only metrics specified in the filter
 * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
 * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
 * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetrics(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let details = (options && options.details !== undefined) ? options.details : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (details !== null && details !== undefined && typeof details !== 'boolean') {
      throw new Error('details must be of type boolean.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (details !== null && details !== undefined) {
    queryParameters.push('details=' + encodeURIComponent(details.toString()));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a web app.
 *
 * Restores a web app.
 *
 * @param {string} subscriptionName Azure subscription
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationOptions Migration migrationOptions
 *
 * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
 * connection string.
 *
 * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
 *
 * @param {boolean} [migrationOptions.switchSiteAfterMigration]
 * <code>true</code>if the app should be switched over; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
 * if the app should be read only during copy operation; otherwise,
 * <code>false</code>.
 *
 * @param {string} [migrationOptions.name] Resource Name.
 *
 * @param {string} [migrationOptions.kind] Kind of resource.
 *
 * @param {string} migrationOptions.location Resource Location.
 *
 * @param {string} [migrationOptions.type] Resource type.
 *
 * @param {object} [migrationOptions.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageMigrationResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageMigrationResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * @summary Migrates a local (in-app) MySql database to a remote MySql
 * database.
 *
 * Migrates a local (in-app) MySql database to a remote MySql database.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationRequestEnvelope MySql migration options
 *
 * @param {string} [migrationRequestEnvelope.connectionString] Connection
 * string to the remote MySQL database to which data should be migrated.
 *
 * @param {string} [migrationRequestEnvelope.name] Resource Name.
 *
 * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
 *
 * @param {string} migrationRequestEnvelope.location Resource Location.
 *
 * @param {string} [migrationRequestEnvelope.type] Resource type.
 *
 * @param {object} [migrationRequestEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Operation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Operation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns the status of MySql in app migration, if one is active, and
 * whether or not MySql in app is enabled
 *
 * Returns the status of MySql in app migration, if one is active, and whether
 * or not MySql in app is enabled
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MigrateMySqlStatus} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMigrateMySqlStatus(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MigrateMySqlStatus']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} view The type of view. This can either be "summary" or
 * "detailed".
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NetworkFeatures} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNetworkFeatures(resourceGroupName, name, view, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (view === null || view === undefined || typeof view.valueOf() !== 'string') {
      throw new Error('view cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{view}', encodeURIComponent(view));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NetworkFeatures']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start capturing network packets for the site.
 *
 * Start capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.durationInSeconds] The duration to keep capturing
 * in seconds.
 *
 * @param {number} [options.maxFrameLength] The maximum frame length in bytes
 * (Optional).
 *
 * @param {string} [options.sasUrl] The Blob URL to store capture file.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startWebSiteNetworkTrace(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let durationInSeconds = (options && options.durationInSeconds !== undefined) ? options.durationInSeconds : undefined;
  let maxFrameLength = (options && options.maxFrameLength !== undefined) ? options.maxFrameLength : undefined;
  let sasUrl = (options && options.sasUrl !== undefined) ? options.sasUrl : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (durationInSeconds !== null && durationInSeconds !== undefined && typeof durationInSeconds !== 'number') {
      throw new Error('durationInSeconds must be of type number.');
    }
    if (maxFrameLength !== null && maxFrameLength !== undefined && typeof maxFrameLength !== 'number') {
      throw new Error('maxFrameLength must be of type number.');
    }
    if (sasUrl !== null && sasUrl !== undefined && typeof sasUrl.valueOf() !== 'string') {
      throw new Error('sasUrl must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (durationInSeconds !== null && durationInSeconds !== undefined) {
    queryParameters.push('durationInSeconds=' + encodeURIComponent(durationInSeconds.toString()));
  }
  if (maxFrameLength !== null && maxFrameLength !== undefined) {
    queryParameters.push('maxFrameLength=' + encodeURIComponent(maxFrameLength.toString()));
  }
  if (sasUrl !== null && sasUrl !== undefined) {
    queryParameters.push('sasUrl=' + encodeURIComponent(sasUrl));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stop ongoing capturing network packets for the site.
 *
 * Stop ongoing capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopWebSiteNetworkTrace(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Generates a new publishing password for an app (or deployment slot,
 * if specified).
 *
 * Generates a new publishing password for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _generateNewSitePublishingPassword(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only usages/metrics specified in the
 * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
 * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
 * eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCounters(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets web app's event logs.
 *
 * Gets web app's event logs.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SitePhpErrorLogFlag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSitePhpErrorLogFlag(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SitePhpErrorLogFlag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the premier add-ons of an app.
 *
 * Gets the premier add-ons of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPremierAddOns(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a named add-on of an app.
 *
 * Gets a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPremierAddOn(resourceGroupName, name, premierAddOnName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a named add-on of an app.
 *
 * Updates a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} premierAddOn A JSON representation of the edited premier
 * add-on.
 *
 * @param {string} [premierAddOn.sku] SKU.
 *
 * @param {string} [premierAddOn.product] Product.
 *
 * @param {string} [premierAddOn.vendor] Vendor.
 *
 * @param {string} [premierAddOn.premierAddOnName] Name.
 *
 * @param {string} [premierAddOn.premierAddOnLocation] Location.
 *
 * @param {object} [premierAddOn.premierAddOnTags] Tags.
 *
 * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
 *
 * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
 *
 * @param {string} [premierAddOn.name] Resource Name.
 *
 * @param {string} [premierAddOn.kind] Kind of resource.
 *
 * @param {string} premierAddOn.location Resource Location.
 *
 * @param {string} [premierAddOn.type] Resource type.
 *
 * @param {object} [premierAddOn.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOn === null || premierAddOn === undefined) {
      throw new Error('premierAddOn cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (premierAddOn !== null && premierAddOn !== undefined) {
      let requestModelMapper = new client.models['PremierAddOn']().mapper();
      requestModel = client.serialize(requestModelMapper, premierAddOn, 'premierAddOn');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(premierAddOn, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a premier add-on from an app.
 *
 * Delete a premier add-on from an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the publishing profile for an app (or deployment slot, if
 * specified).
 *
 * Gets the publishing profile for an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.format] Name of the format. Valid values are:
 * FileZilla3
 * WebDeploy -- default
 * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let format = (options && options.format !== undefined) ? options.format : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (format !== null && format !== undefined && typeof format.valueOf() !== 'string') {
      throw new Error('format must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let publishingProfileOptions;
  if (format !== null && format !== undefined) {
    publishingProfileOptions = new client.models['CsmPublishingProfileOptions']();
    publishingProfileOptions.format = format;
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (publishingProfileOptions !== null && publishingProfileOptions !== undefined) {
      let requestModelMapper = new client.models['CsmPublishingProfileOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, publishingProfileOptions, 'publishingProfileOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(publishingProfileOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }

    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(`Unexpected status code: ${statusCode}`);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        if (responseBody !== undefined) parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }

    // Create Result
    let result = response;
    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recover(resourceGroupName, name, recoveryEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRecover(resourceGroupName, name, recoveryEntity, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetProductionSlotConfig(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts an app (or deployment slot, if specified).
 *
 * Restarts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.softRestart] Specify true to apply the
 * configuration settings and restarts the app only if necessary. By default,
 * the API always restarts and reprovisions the app.
 *
 * @param {boolean} [options.synchronous] Specify true to block until the app
 * is restarted. By default, it is set to false, and the API responds
 * immediately (asynchronous).
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restart(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let softRestart = (options && options.softRestart !== undefined) ? options.softRestart : undefined;
  let synchronous = (options && options.synchronous !== undefined) ? options.synchronous : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (softRestart !== null && softRestart !== undefined && typeof softRestart !== 'boolean') {
      throw new Error('softRestart must be of type boolean.');
    }
    if (synchronous !== null && synchronous !== undefined && typeof synchronous !== 'boolean') {
      throw new Error('synchronous must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (softRestart !== null && softRestart !== undefined) {
    queryParameters.push('softRestart=' + encodeURIComponent(softRestart.toString()));
  }
  if (synchronous !== null && synchronous !== undefined) {
    queryParameters.push('synchronous=' + encodeURIComponent(synchronous.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's deployment slots.
 *
 * Gets an app's deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlots(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the details of a web, mobile, or API app.
 *
 * Gets the details of a web, mobile, or API app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. By default, this API
 * returns the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
 * enabled; otherwise, <code>false</code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
 * otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * <code>true</code> if request tracing is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * <code>true</code> if remote debugging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * <code>true</code> if detailed error logging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * <code>true</code> to use 32-bit worker process; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
 * Always On is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
 * if Auto Heal is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
 * default is <code>false</code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
 * enable client affinity; <code>false</code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is <code>true</code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, <code>false</code>. Default is <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
 * disable the public hostnames of the app; otherwise, <code>false</code>.
 * If <code>true</code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
 * overwrite destination app; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * <code>true</code> to clone custom hostnames from source app; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * <code>true</code> to clone source control from source app; otherwise,
 * <code>false</code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * <code>true</code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot to create or update. By
 * default, this API attempts to create or modify the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * Deletes a web, mobile, or API app, or one of the deployment slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app to delete.
 *
 * @param {string} slot Name of the deployment slot to delete. By default, the
 * API deletes the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
 * deleted
 *
 * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
 * Service plan will be empty after app deletion and you want to delete the
 * empty App Service plan. By default, the empty App Service plan is not
 * deleted.
 *
 * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
 * skipped
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let deleteMetrics = (options && options.deleteMetrics !== undefined) ? options.deleteMetrics : undefined;
  let deleteEmptyServerFarm = (options && options.deleteEmptyServerFarm !== undefined) ? options.deleteEmptyServerFarm : undefined;
  let skipDnsRegistration = (options && options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (deleteMetrics !== null && deleteMetrics !== undefined && typeof deleteMetrics !== 'boolean') {
      throw new Error('deleteMetrics must be of type boolean.');
    }
    if (deleteEmptyServerFarm !== null && deleteEmptyServerFarm !== undefined && typeof deleteEmptyServerFarm !== 'boolean') {
      throw new Error('deleteEmptyServerFarm must be of type boolean.');
    }
    if (skipDnsRegistration !== null && skipDnsRegistration !== undefined && typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (deleteMetrics !== null && deleteMetrics !== undefined) {
    queryParameters.push('deleteMetrics=' + encodeURIComponent(deleteMetrics.toString()));
  }
  if (deleteEmptyServerFarm !== null && deleteEmptyServerFarm !== undefined) {
    queryParameters.push('deleteEmptyServerFarm=' + encodeURIComponent(deleteEmptyServerFarm.toString()));
  }
  if (skipDnsRegistration !== null && skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Analyze a custom hostname.
 *
 * Analyze a custom hostname.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.hostName] Custom hostname
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CustomHostnameAnalysisResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let hostName = (options && options.hostName !== undefined) ? options.hostName : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName !== null && hostName !== undefined && typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (hostName !== null && hostName !== undefined) {
    queryParameters.push('hostName=' + encodeURIComponent(hostName));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CustomHostnameAnalysisResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Applies the configuration settings from the target slot onto the
 * current slot.
 *
 * Applies the configuration settings from the target slot onto the current
 * slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a backup of an app.
 *
 * Creates a backup of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Backup configuration. You can use the JSON response
 * from the POST action as input here.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create a backup for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _backupSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get backups of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Discovers an existing app backup that can be restored from a blob
 * in Azure storage.
 *
 * Discovers an existing app backup that can be restored from a blob in Azure
 * storage.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request A RestoreRequest object that includes Azure storage
 * URL and blog name for discovery of backup.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will perform discovery for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _discoverRestoreSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a backup of an app by its ID.
 *
 * Gets a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a backup of an app by its ID.
 *
 * Deletes a backup of an app by its ID.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupSlot(resourceGroupName, name, backupId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets status of a web app backup that may be in progress, including
 * secrets associated with the backup, such as the Azure Storage SAS URL. Also
 * can be used to update the SAS URL for the backup if a new URL is passed in
 * the request body.
 *
 * Gets status of a web app backup that may be in progress, including secrets
 * associated with the backup, such as the Azure Storage SAS URL. Also can be
 * used to update the SAS URL for the backup if a new URL is passed in the
 * request body.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} backupId Id of backup
 *
 * @param {object} request Information on backup request
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItem} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItem']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restore a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restoreSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Replaces the application settings of an app.
 *
 * Replaces the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} appSettings Application settings of the app.
 *
 * @param {object} [appSettings.properties] Settings.
 *
 * @param {string} [appSettings.name] Resource Name.
 *
 * @param {string} [appSettings.kind] Kind of resource.
 *
 * @param {string} appSettings.location Resource Location.
 *
 * @param {string} [appSettings.type] Resource type.
 *
 * @param {object} [appSettings.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the application settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (appSettings === null || appSettings === undefined) {
      throw new Error('appSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (appSettings !== null && appSettings !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, appSettings, 'appSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(appSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the application settings of an app.
 *
 * Gets the application settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the application settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listApplicationSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the Authentication / Authorization settings associated with
 * web app.
 *
 * Updates the Authentication / Authorization settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} siteAuthSettings Auth settings associated with web app
 *
 * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
 * Authentication / Authorization feature is enabled for the current app;
 * otherwise, <code>false</code>.
 *
 * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
 * Authentication / Authorization feature in use for the current app.
 * The setting in this value can control the behavior of certain features in
 * the Authentication / Authorization module.
 *
 * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
 * take when an unauthenticated client attempts to access the app. Possible
 * values include: 'RedirectToLoginPage', 'AllowAnonymous'
 *
 * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
 * durably store platform-specific security tokens that are obtained during
 * login flows; otherwise, <code>false</code>.
 * The default is <code>false</code>.
 *
 * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
 * that can be redirected to as part of logging in or logging out of the app.
 * Note that the query string part of the URL is ignored.
 * This is an advanced setting typically only needed by Windows Store
 * application backends.
 * Note that URLs within the current domain are always implicitly allowed.
 *
 * @param {string} [siteAuthSettings.defaultProvider] The default
 * authentication provider to use when multiple providers are configured.
 * This setting is only needed if multiple providers are configured and the
 * unauthenticated client
 * action is set to "RedirectToLoginPage". Possible values include:
 * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
 *
 * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
 * hours after session token expiration that a session token can be used to
 * call the token refresh API. The default is 72 hours.
 *
 * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
 * party application, known as the client_id.
 * This setting is required for enabling OpenID Connection authentication with
 * Azure Active Directory or
 * other 3rd party OpenID Connect providers.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
 * relying party application (in Azure Active Directory, this is also referred
 * to as the Key).
 * This setting is optional. If no client secret is configured, the OpenID
 * Connect implicit auth flow is used to authenticate end users.
 * Otherwise, the OpenID Connect Authorization Code Flow is used to
 * authenticate end users.
 * More information on OpenID Connect:
 * http://openid.net/specs/openid-connect-core-1_0.html
 *
 * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
 * represents the entity which issues access tokens for this application.
 * When using Azure Active Directory, this value is the URI of the directory
 * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
 * This URI is a case-sensitive identifier for the token issuer.
 * More information on OpenID Connect Discovery:
 * http://openid.net/specs/openid-connect-discovery-1_0.html
 *
 * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
 * to consider when validating JWTs issued by
 * Azure Active Directory. Note that the <code>ClientID</code> value is always
 * considered an
 * allowed audience, regardless of this setting.
 *
 * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
 * send to the OpenID Connect authorization endpoint when
 * a user logs in. Each parameter must be in the form "key=value".
 *
 * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
 * ID for the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.googleClientSecret] The client secret
 * associated with the Google web application.
 * This setting is required for enabling Google Sign-In.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Google Sign-In authentication.
 * This setting is optional. If not specified, "openid", "profile", and "email"
 * are used as default scopes.
 * Google Sign-In documentation:
 * https://developers.google.com/identity/sign-in/web/
 *
 * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
 * app used for login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
 * Facebook app used for Facebook Login.
 * This setting is required for enabling Facebook Login.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
 * that will be requested as part of Facebook Login authentication.
 * This setting is optional.
 * Facebook Login documentation:
 * https://developers.facebook.com/docs/facebook-login
 *
 * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
 * consumer key of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
 * consumer secret of the Twitter application used for sign-in.
 * This setting is required for enabling Twitter Sign-In.
 * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
 * client ID that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
 * 2.0 client secret that was created for the app used for authentication.
 * This setting is required for enabling Microsoft Account authentication.
 * Microsoft Account OAuth documentation:
 * https://dev.onedrive.com/auth/msa_oauth.htm
 *
 * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
 * scopes that will be requested as part of Microsoft Account authentication.
 * This setting is optional. If not specified, "wl.basic" is used as the
 * default scope.
 * Microsoft Account Scopes and permissions documentation:
 * https://msdn.microsoft.com/en-us/library/dn631845.aspx
 *
 * @param {string} [siteAuthSettings.name] Resource Name.
 *
 * @param {string} [siteAuthSettings.kind] Kind of resource.
 *
 * @param {string} siteAuthSettings.location Resource Location.
 *
 * @param {string} [siteAuthSettings.type] Resource type.
 *
 * @param {object} [siteAuthSettings.tags] Resource tags.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteAuthSettings === null || siteAuthSettings === undefined) {
      throw new Error('siteAuthSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteAuthSettings !== null && siteAuthSettings !== undefined) {
      let requestModelMapper = new client.models['SiteAuthSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, siteAuthSettings, 'siteAuthSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteAuthSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Authentication/Authorization settings of an app.
 *
 * Gets the Authentication/Authorization settings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteAuthSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAuthSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteAuthSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the backup configuration of an app.
 *
 * Updates the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} request Edited backup configuration.
 *
 * @param {string} [request.backupRequestName] Name of the backup.
 *
 * @param {boolean} [request.enabled] True if the backup schedule is enabled
 * (must be included in that case), false if the backup schedule should be
 * disabled.
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {object} [request.backupSchedule] Schedule for the backup if it is
 * executed periodically.
 *
 * @param {number} request.backupSchedule.frequencyInterval How often should be
 * the backup executed (e.g. for weekly backup, this should be set to 7 and
 * FrequencyUnit should be set to Day)
 *
 * @param {string} request.backupSchedule.frequencyUnit The unit of time for
 * how often should be the backup executed (e.g. for weekly backup, this should
 * be set to Day and FrequencyInterval should be set to 7). Possible values
 * include: 'Day', 'Hour'
 *
 * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
 * retention policy should always keep at least one backup in the storage
 * account, regardless how old it is; false otherwise.
 *
 * @param {number} request.backupSchedule.retentionPeriodInDays After how many
 * days backups should be deleted.
 *
 * @param {date} [request.backupSchedule.startTime] When the schedule should
 * start working.
 *
 * @param {array} [request.databases] Databases included in the backup.
 *
 * @param {string} [request.backupRequestType] Type of the backup. Possible
 * values include: 'Default', 'Clone', 'Relocation'
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['BackupRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes the backup configuration of an app.
 *
 * Deletes the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the backup configuration of an app.
 *
 * Gets the backup configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the backup configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupRequest} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getBackupConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupRequest']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the connection strings of an app.
 *
 * Replaces the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} connectionStrings Connection strings of the app or
 * deployment slot. See example.
 *
 * @param {object} [connectionStrings.properties] Connection strings.
 *
 * @param {string} [connectionStrings.name] Resource Name.
 *
 * @param {string} [connectionStrings.kind] Kind of resource.
 *
 * @param {string} connectionStrings.location Resource Location.
 *
 * @param {string} [connectionStrings.type] Resource type.
 *
 * @param {object} [connectionStrings.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the connection settings for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (connectionStrings === null || connectionStrings === undefined) {
      throw new Error('connectionStrings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionStrings !== null && connectionStrings !== undefined) {
      let requestModelMapper = new client.models['ConnectionStringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionStrings, 'connectionStrings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionStrings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the connection strings of an app.
 *
 * Gets the connection strings of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the connection settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ConnectionStringDictionary} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConnectionStringsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ConnectionStringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the logging configuration of an app.
 *
 * Gets the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the logging configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the logging configuration of an app.
 *
 * Updates the logging configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
 * the logging configuration to change in the "properties" property.
 *
 * @param {object} [siteLogsConfig.applicationLogs] Application logs
 * configuration.
 *
 * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
 * to file system configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
 * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
 * Application logs to azure table storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
 * URL to an Azure table with add/query/delete permissions.
 *
 * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
 * Application logs to blob storage configuration.
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
 * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
 * 'Error'
 *
 * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
 * url to a azure blob container with read/write/list/delete permissions.
 *
 * @param {number}
 * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
 * in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
 *
 * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
 * system configuration.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
 * size in megabytes that http log files can use.
 * When reached old log files will be removed to make space for new ones.
 * Value can range between 25 and 100.
 *
 * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
 * Retention in days.
 * Remove files older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
 * azure blob storage configuration.
 *
 * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
 * a azure blob container with read/write/list/delete permissions.
 *
 * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
 * Retention in days.
 * Remove blobs older than X days.
 * 0 or lower means no retention.
 *
 * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
 *
 * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
 * tracing configuration.
 *
 * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
 * messages configuration.
 *
 * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
 *
 * @param {string} [siteLogsConfig.name] Resource Name.
 *
 * @param {string} [siteLogsConfig.kind] Kind of resource.
 *
 * @param {string} siteLogsConfig.location Resource Location.
 *
 * @param {string} [siteLogsConfig.type] Resource type.
 *
 * @param {object} [siteLogsConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the logging configuration for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteLogsConfig} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteLogsConfig === null || siteLogsConfig === undefined) {
      throw new Error('siteLogsConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteLogsConfig !== null && siteLogsConfig !== undefined) {
      let requestModelMapper = new client.models['SiteLogsConfig']().mapper();
      requestModel = client.serialize(requestModelMapper, siteLogsConfig, 'siteLogsConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteLogsConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteLogsConfig']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Replaces the metadata of an app.
 *
 * Replaces the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} metadata Edited metadata of the app or deployment slot. See
 * example.
 *
 * @param {object} [metadata.properties] Settings.
 *
 * @param {string} [metadata.name] Resource Name.
 *
 * @param {string} [metadata.kind] Kind of resource.
 *
 * @param {string} metadata.location Resource Location.
 *
 * @param {string} [metadata.type] Resource type.
 *
 * @param {object} [metadata.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the metadata for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateMetadataSlot(resourceGroupName, name, metadata, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (metadata === null || metadata === undefined) {
      throw new Error('metadata cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (metadata !== null && metadata !== undefined) {
      let requestModelMapper = new client.models['StringDictionary']().mapper();
      requestModel = client.serialize(requestModelMapper, metadata, 'metadata');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(metadata, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the metadata of an app.
 *
 * Gets the metadata of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the metadata for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StringDictionary} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetadataSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StringDictionary']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing credentials for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingCredentialsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Updates the Push settings associated with web app.
 *
 * Updates the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} pushSettings Push settings associated with web app
 *
 * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
 * whether the Push endpoint is enabled.
 *
 * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
 * containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
 * containing a list of tags that require user authentication to be used in the
 * push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (pushSettings === null || pushSettings === undefined) {
      throw new Error('pushSettings cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (pushSettings !== null && pushSettings !== undefined) {
      let requestModelMapper = new client.models['PushSettings']().mapper();
      requestModel = client.serialize(requestModelMapper, pushSettings, 'pushSettings');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(pushSettings, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Push settings associated with web app.
 *
 * Gets the Push settings associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PushSettings} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSitePushSettingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PushSettings']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the configuration of an app, such as platform version and
 * bitness, default documents, virtual applications, Always On, etc.
 *
 * Gets the configuration of an app, such as platform version and bitness,
 * default documents, virtual applications, Always On, etc.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
 * request tracing is enabled; otherwise, <code>false</code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
 * remote debugging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
 * logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
 * if detailed error logging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
 * 32-bit worker process; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
 * WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
 * enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
 * is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
 * local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null && siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the configuration of an app.
 *
 * Updates the configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteConfig JSON representation of a SiteConfig object. See
 * example.
 *
 * @param {number} [siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
 *
 * @param {string} [siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
 *
 * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
 * request tracing is enabled; otherwise, <code>false</code>.
 *
 * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
 * expiration time.
 *
 * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
 * remote debugging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
 * version.
 *
 * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
 * logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
 * limit.
 *
 * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
 * if detailed error logging is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.publishingUsername] Publishing user name.
 *
 * @param {array} [siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteConfig.connectionStrings] Connection strings.
 *
 * @param {array} [siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteConfig.scmType] SCM type. Possible values include:
 * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
 * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
 * 'VSO'
 *
 * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
 * 32-bit worker process; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
 * WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
 * enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteConfig.javaContainerVersion] Java container version.
 *
 * @param {string} [siteConfig.appCommandLine] App command line to launch.
 *
 * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
 * Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteConfig.virtualApplications] Virtual applications.
 *
 * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
 * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
 * 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteConfig.experiments] This is work around for polymophic
 * types.
 *
 * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
 *
 * @param {object} [siteConfig.limits] Site limits.
 *
 * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
 * usage percentage.
 *
 * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
 * usage in MB.
 *
 * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
 * size usage in MB.
 *
 * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
 * is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
 * when to execute the auto-heal actions.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
 * total requests.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
 * Time interval.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
 * on status codes.
 *
 * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
 * based on request execution time.
 *
 * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
 * Time taken.
 *
 * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
 * Count.
 *
 * @param {string}
 * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
 *
 * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
 * when a rule is triggered.
 *
 * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
 * action to be taken. Possible values include: 'Recycle', 'LogEvent',
 * 'CustomAction'
 *
 * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
 * action to be taken.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
 * Executable to be run.
 *
 * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
 * settings.
 *
 * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
 * origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
 * indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
 * string containing a list of tags that are whitelisted for use by the push
 * registration endpoint.
 *
 * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
 * string containing a list of tags that require user authentication to be used
 * in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
 * containing a list of dynamic tags that will be evaluated from user claims in
 * the push registration endpoint.
 *
 * @param {object} [siteConfig.apiDefinition] Information about the formal API
 * definition for the app.
 *
 * @param {string} [siteConfig.apiDefinition.url] The URL of the API
 * definition.
 *
 * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
 *
 * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
 * local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
 *
 * @param {string} [siteConfig.name] Resource Name.
 *
 * @param {string} [siteConfig.kind] Kind of resource.
 *
 * @param {string} siteConfig.location Resource Location.
 *
 * @param {string} [siteConfig.type] Resource type.
 *
 * @param {object} [siteConfig.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteConfig === null || siteConfig === undefined) {
      throw new Error('siteConfig cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteConfig !== null && siteConfig !== undefined) {
      let requestModelMapper = new client.models['SiteConfigResource']().mapper();
      requestModel = client.serialize(requestModelMapper, siteConfig, 'siteConfig');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteConfig, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a list of web app configuration snapshots identifiers. Each
 * element of the list contains a timestamp and the ID of the snapshot.
 *
 * Gets a list of web app configuration snapshots identifiers. Each element of
 * the list contains a timestamp and the ID of the snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'SiteConfigurationSnapshotInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'SiteConfigurationSnapshotInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a snapshot of the configuration of an app at a previous point
 * in time.
 *
 * Gets a snapshot of the configuration of an app at a previous point in time.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteConfigResource} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteConfigResource']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Reverts the configuration of an app to a previous snapshot.
 *
 * Reverts the configuration of an app to a previous snapshot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} snapshotId The ID of the snapshot to read.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will return configuration for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (snapshotId === null || snapshotId === undefined || typeof snapshotId.valueOf() !== 'string') {
      throw new Error('snapshotId cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{snapshotId}', encodeURIComponent(snapshotId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API returns deployments for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets a deployment for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeploymentSlot(resourceGroupName, name, id, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API creates a deployment for the production slot.
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null && deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API deletes a deployment for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDeploymentSlot(resourceGroupName, name, id, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get domain ownership identifier for web app.
 *
 * Get domain ownership identifier for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null && domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a domain ownership identifier for a web app.
 *
 * Deletes a domain ownership identifier for a web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a domain ownership identifier for web app, or updates an
 * existing ownership identifier.
 *
 * Creates a domain ownership identifier for web app, or updates an existing
 * ownership identifier.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} domainOwnershipIdentifierName Name of domain ownership
 * identifier.
 *
 * @param {object} domainOwnershipIdentifier A JSON representation of the
 * domain ownership properties.
 *
 * @param {string} [domainOwnershipIdentifier.identifierId] ID.
 *
 * @param {string} [domainOwnershipIdentifier.name] Resource Name.
 *
 * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
 *
 * @param {string} domainOwnershipIdentifier.location Resource Location.
 *
 * @param {string} [domainOwnershipIdentifier.type] Resource type.
 *
 * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Identifier} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifierName === null || domainOwnershipIdentifierName === undefined || typeof domainOwnershipIdentifierName.valueOf() !== 'string') {
      throw new Error('domainOwnershipIdentifierName cannot be null or undefined and it must be of type string.');
    }
    if (domainOwnershipIdentifier === null || domainOwnershipIdentifier === undefined) {
      throw new Error('domainOwnershipIdentifier cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{domainOwnershipIdentifierName}', encodeURIComponent(domainOwnershipIdentifierName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (domainOwnershipIdentifier !== null && domainOwnershipIdentifier !== undefined) {
      let requestModelMapper = new client.models['Identifier']().mapper();
      requestModel = client.serialize(requestModelMapper, domainOwnershipIdentifier, 'domainOwnershipIdentifier');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(domainOwnershipIdentifier, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Identifier']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets hostname bindings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * Get the named hostname binding for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API the named binding for the production slot.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a hostname binding for an app.
 *
 * Creates a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} hostNameBinding Binding details. This is the JSON
 * representation of a HostNameBinding object.
 *
 * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
 *
 * @param {string} [hostNameBinding.siteName] App Service app name.
 *
 * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
 * resource URI.
 *
 * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
 *
 * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
 * Possible values include: 'Website', 'TrafficManager'
 *
 * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
 * record type. Possible values include: 'CName', 'A'
 *
 * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
 * values include: 'Verified', 'Managed'
 *
 * @param {string} [hostNameBinding.sslState] SSL type. Possible values
 * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
 *
 * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
 *
 * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
 * the hostname if IP based SSL is enabled.
 *
 * @param {string} [hostNameBinding.name] Resource Name.
 *
 * @param {string} [hostNameBinding.kind] Kind of resource.
 *
 * @param {string} hostNameBinding.location Resource Location.
 *
 * @param {string} [hostNameBinding.type] Resource type.
 *
 * @param {object} [hostNameBinding.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create a binding for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBinding} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (hostNameBinding === null || hostNameBinding === undefined) {
      throw new Error('hostNameBinding cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (hostNameBinding !== null && hostNameBinding !== undefined) {
      let requestModelMapper = new client.models['HostNameBinding']().mapper();
      requestModel = client.serialize(requestModelMapper, hostNameBinding, 'hostNameBinding');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(hostNameBinding, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBinding']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a hostname binding for an app.
 *
 * Deletes a hostname binding for an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the binding for the production slot.
 *
 * @param {string} hostName Hostname in the hostname binding.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (hostName === null || hostName === undefined || typeof hostName.valueOf() !== 'string') {
      throw new Error('hostName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{hostName}', encodeURIComponent(hostName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
 * App.
 *
 * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Removes a Hybrid Connection from this site.
 *
 * Removes a Hybrid Connection from this site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new Hybrid Connection using a Service Bus relay.
 *
 * Creates a new Hybrid Connection using a Service Bus relay.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {object} connectionEnvelope The details of the hybrid connection
 *
 * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
 * Service Bus namespace.
 *
 * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
 * relay.
 *
 * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
 * Bus relay.
 *
 * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
 *
 * @param {number} [connectionEnvelope.port] The port of the endpoint.
 *
 * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
 * key which has Send permissions. This is used to authenticate to Service Bus.
 *
 * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
 * Bus key. This is used to authenticate to Service Bus. In ARM this key will
 * not be returned
 * normally, use the POST /listKeys API instead.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['HybridConnection']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the send key name and value for a Hybrid Connection.
 *
 * Gets the send key name and value for a Hybrid Connection.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} namespaceName The namespace for this hybrid connection
 *
 * @param {string} relayName The relay name for this hybrid connection
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnectionKey} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (namespaceName === null || namespaceName === undefined || typeof namespaceName.valueOf() !== 'string') {
      throw new Error('namespaceName cannot be null or undefined and it must be of type string.');
    }
    if (relayName === null || relayName === undefined || typeof relayName.valueOf() !== 'string') {
      throw new Error('relayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{namespaceName}', encodeURIComponent(namespaceName));
  requestUrl = requestUrl.replace('{relayName}', encodeURIComponent(relayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnectionKey']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * Retrieves all Service Bus Hybrid Connections used by this Web App.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app
 *
 * @param {string} slot The name of the slot for the web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HybridConnection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHybridConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HybridConnection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets hybrid connections configured for an app (or deployment slot,
 * if specified).
 *
 * Gets hybrid connections configured for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get hybrid connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a hybrid connection configuration by its name.
 *
 * Gets a hybrid connection configuration by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a hybrid connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create or update a hybrid connection for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a relay service connection by its name.
 *
 * Deletes a relay service connection by its name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete a hybrid connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new hybrid connection configuration (PUT), or updates an
 * existing one (PATCH).
 *
 * Creates a new hybrid connection configuration (PUT), or updates an existing
 * one (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} entityName Name of the hybrid connection configuration.
 *
 * @param {object} connectionEnvelope Details of the hybrid connection
 * configuration.
 *
 * @param {string} [connectionEnvelope.entityName]
 *
 * @param {string} [connectionEnvelope.entityConnectionString]
 *
 * @param {string} [connectionEnvelope.resourceType]
 *
 * @param {string} [connectionEnvelope.resourceConnectionString]
 *
 * @param {string} [connectionEnvelope.hostname]
 *
 * @param {number} [connectionEnvelope.port]
 *
 * @param {string} [connectionEnvelope.biztalkUri]
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will create or update a hybrid connection for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RelayServiceConnectionEntity} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['RelayServiceConnectionEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelayServiceConnectionEntity']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets the production slot instances.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API returns deployments for the production slot.
 *
 * @param {string} instanceId The ID of a specific scaled-out instance. This is
 * the value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get a deployment by its ID for an app, a specific deployment slot,
 * and/or a specific scaled-out instance.
 *
 * Get a deployment by its ID for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API gets a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Create a deployment for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * Create a deployment for an app, a specific deployment slot, and/or a
 * specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id ID of an existing deployment.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API creates a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} deployment Deployment details.
 *
 * @param {string} [deployment.deploymentId] ID.
 *
 * @param {number} [deployment.status] Status.
 *
 * @param {string} [deployment.message] Message.
 *
 * @param {string} [deployment.author] Author.
 *
 * @param {string} [deployment.deployer] Deployer.
 *
 * @param {string} [deployment.authorEmail] Author email.
 *
 * @param {date} [deployment.startTime] Start time.
 *
 * @param {date} [deployment.endTime] End time.
 *
 * @param {boolean} [deployment.active] Active.
 *
 * @param {string} [deployment.details] Detail.
 *
 * @param {string} [deployment.name] Resource Name.
 *
 * @param {string} [deployment.kind] Kind of resource.
 *
 * @param {string} deployment.location Resource Location.
 *
 * @param {string} [deployment.type] Resource type.
 *
 * @param {object} [deployment.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Deployment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (deployment === null || deployment === undefined) {
      throw new Error('deployment cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (deployment !== null && deployment !== undefined) {
      let requestModelMapper = new client.models['Deployment']().mapper();
      requestModel = client.serialize(requestModelMapper, deployment, 'deployment');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(deployment, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Deployment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a deployment by its ID for an app, a specific deployment
 * slot, and/or a specific scaled-out instance.
 *
 * Delete a deployment by its ID for an app, a specific deployment slot, and/or
 * a specific scaled-out instance.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} id Deployment ID.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API deletes a deployment for the production slot.
 *
 * @param {string} instanceId ID of a specific scaled-out instance. This is the
 * value of the name property in the JSON response from "GET
 * api/sites/{siteName}/instances"
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
      throw new Error('id cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{id}', encodeURIComponent(id));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * Shows whether an app can be cloned to another resource group or
 * subscription.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. By default, this API
 * returns information on the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteCloneability} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _isCloneableSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteCloneability']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get metric definitions of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get metrics of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.details] Specify "true" to include metric details
 * in the response. It is "false" by default.
 *
 * @param {string} [options.filter] Return only metrics specified in the filter
 * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
 * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
 * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let details = (options && options.details !== undefined) ? options.details : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (details !== null && details !== undefined && typeof details !== 'boolean') {
      throw new Error('details must be of type boolean.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (details !== null && details !== undefined) {
    queryParameters.push('details=' + encodeURIComponent(details.toString()));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns the status of MySql in app migration, if one is active, and
 * whether or not MySql in app is enabled
 *
 * Returns the status of MySql in app migration, if one is active, and whether
 * or not MySql in app is enabled
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of the deployment slot
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MigrateMySqlStatus} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MigrateMySqlStatus']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * Gets all network features used by the app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} view The type of view. This can either be "summary" or
 * "detailed".
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get network features for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link NetworkFeatures} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (view === null || view === undefined || typeof view.valueOf() !== 'string') {
      throw new Error('view cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{view}', encodeURIComponent(view));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NetworkFeatures']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Start capturing network packets for the site.
 *
 * Start capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {string} slot The name of the slot for this web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.durationInSeconds] The duration to keep capturing
 * in seconds.
 *
 * @param {number} [options.maxFrameLength] The maximum frame length in bytes
 * (Optional).
 *
 * @param {string} [options.sasUrl] The Blob URL to store capture file.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let durationInSeconds = (options && options.durationInSeconds !== undefined) ? options.durationInSeconds : undefined;
  let maxFrameLength = (options && options.maxFrameLength !== undefined) ? options.maxFrameLength : undefined;
  let sasUrl = (options && options.sasUrl !== undefined) ? options.sasUrl : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (durationInSeconds !== null && durationInSeconds !== undefined && typeof durationInSeconds !== 'number') {
      throw new Error('durationInSeconds must be of type number.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (maxFrameLength !== null && maxFrameLength !== undefined && typeof maxFrameLength !== 'number') {
      throw new Error('maxFrameLength must be of type number.');
    }
    if (sasUrl !== null && sasUrl !== undefined && typeof sasUrl.valueOf() !== 'string') {
      throw new Error('sasUrl must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (durationInSeconds !== null && durationInSeconds !== undefined) {
    queryParameters.push('durationInSeconds=' + encodeURIComponent(durationInSeconds.toString()));
  }
  if (maxFrameLength !== null && maxFrameLength !== undefined) {
    queryParameters.push('maxFrameLength=' + encodeURIComponent(maxFrameLength.toString()));
  }
  if (sasUrl !== null && sasUrl !== undefined) {
    queryParameters.push('sasUrl=' + encodeURIComponent(sasUrl));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stop ongoing capturing network packets for the site.
 *
 * Stop ongoing capturing network packets for the site.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name The name of the web app.
 *
 * @param {string} slot The name of the slot for this web app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {string} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'String'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Generates a new publishing password for an app (or deployment slot,
 * if specified).
 *
 * Generates a new publishing password for an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API generate a new publishing password for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot. **** CURRENTLY UNUSED *****
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only usages/metrics specified in the
 * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
 * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
 * eq duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets web app's event logs.
 *
 * Gets web app's event logs.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SitePhpErrorLogFlag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SitePhpErrorLogFlag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the premier add-ons of an app.
 *
 * Gets the premier add-ons of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the premier add-ons for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPremierAddOnsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a named add-on of an app.
 *
 * Gets a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates a named add-on of an app.
 *
 * Updates a named add-on of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {object} premierAddOn A JSON representation of the edited premier
 * add-on.
 *
 * @param {string} [premierAddOn.sku] SKU.
 *
 * @param {string} [premierAddOn.product] Product.
 *
 * @param {string} [premierAddOn.vendor] Vendor.
 *
 * @param {string} [premierAddOn.premierAddOnName] Name.
 *
 * @param {string} [premierAddOn.premierAddOnLocation] Location.
 *
 * @param {object} [premierAddOn.premierAddOnTags] Tags.
 *
 * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
 *
 * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
 *
 * @param {string} [premierAddOn.name] Resource Name.
 *
 * @param {string} [premierAddOn.kind] Kind of resource.
 *
 * @param {string} premierAddOn.location Resource Location.
 *
 * @param {string} [premierAddOn.type] Resource type.
 *
 * @param {object} [premierAddOn.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PremierAddOn} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOn === null || premierAddOn === undefined) {
      throw new Error('premierAddOn cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (premierAddOn !== null && premierAddOn !== undefined) {
      let requestModelMapper = new client.models['PremierAddOn']().mapper();
      requestModel = client.serialize(requestModelMapper, premierAddOn, 'premierAddOn');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(premierAddOn, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PremierAddOn']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Delete a premier add-on from an app.
 *
 * Delete a premier add-on from an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} premierAddOnName Add-on name.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the named add-on for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (premierAddOnName === null || premierAddOnName === undefined || typeof premierAddOnName.valueOf() !== 'string') {
      throw new Error('premierAddOnName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{premierAddOnName}', encodeURIComponent(premierAddOnName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the publishing profile for an app (or deployment slot, if
 * specified).
 *
 * Gets the publishing profile for an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing profile for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.format] Name of the format. Valid values are:
 * FileZilla3
 * WebDeploy -- default
 * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let format = (options && options.format !== undefined) ? options.format : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (format !== null && format !== undefined && typeof format.valueOf() !== 'string') {
      throw new Error('format must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }
  let publishingProfileOptions;
  if (format !== null && format !== undefined) {
    publishingProfileOptions = new client.models['CsmPublishingProfileOptions']();
    publishingProfileOptions.format = format;
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (publishingProfileOptions !== null && publishingProfileOptions !== undefined) {
      let requestModelMapper = new client.models['CsmPublishingProfileOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, publishingProfileOptions, 'publishingProfileOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(publishingProfileOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }

    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(`Unexpected status code: ${statusCode}`);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        if (responseBody !== undefined) parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }

    // Create Result
    let result = response;
    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * Resets the configuration settings of the current slot if they were
 * previously modified by calling the API with POST.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API resets configuration settings for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetSlotConfigurationSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restarts an app (or deployment slot, if specified).
 *
 * Restarts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restart the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.softRestart] Specify true to apply the
 * configuration settings and restarts the app only if necessary. By default,
 * the API always restarts and reprovisions the app.
 *
 * @param {boolean} [options.synchronous] Specify true to block until the app
 * is restarted. By default, it is set to false, and the API responds
 * immediately (asynchronous).
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _restartSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let softRestart = (options && options.softRestart !== undefined) ? options.softRestart : undefined;
  let synchronous = (options && options.synchronous !== undefined) ? options.synchronous : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (softRestart !== null && softRestart !== undefined && typeof softRestart !== 'boolean') {
      throw new Error('softRestart must be of type boolean.');
    }
    if (synchronous !== null && synchronous !== undefined && typeof synchronous !== 'boolean') {
      throw new Error('synchronous must be of type boolean.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (softRestart !== null && softRestart !== undefined) {
    queryParameters.push('softRestart=' + encodeURIComponent(softRestart.toString()));
  }
  if (synchronous !== null && synchronous !== undefined) {
    queryParameters.push('synchronous=' + encodeURIComponent(synchronous.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Website Name
 *
 * @param {string} slot Website Slot
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the source control configuration of an app.
 *
 * Gets the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSourceControlSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
 * to limit to manual integration; <code>false</code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * <code>true</code> to enable deployment rollback; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
 * Mercurial repository; <code>false</code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes the source control configuration of an app.
 *
 * Deletes the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSourceControlSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts an app (or deployment slot, if specified).
 *
 * Starts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will start the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _startSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops an app (or deployment slot, if specified).
 *
 * Stops an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will stop the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stopSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sync web app repository.
 *
 * Sync web app repository.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _syncRepositorySlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get quota information of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only information specified in the
 * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
 * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
 * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
 * duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the virtual networks the app (or deployment slot) is connected
 * to.
 *
 * Gets the virtual networks the app (or deployment slot) is connected to.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get virtual network connections for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listVnetConnectionsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'VnetInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'VnetInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a virtual network the app (or deployment slot) is connected to
 * by name.
 *
 * Gets a virtual network the app (or deployment slot) is connected to by name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the named virtual network for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a connection from an app (or deployment slot to a named
 * virtual network.
 *
 * Deletes a connection from an app (or deployment slot to a named virtual
 * network.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will delete the connection for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update connections for the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's Virtual Network gateway.
 *
 * Gets an app's Virtual Network gateway.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get a gateway for the production slot's Virtual
 * Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update a gateway for the production slot's
 * Virtual Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will add or update a gateway for the production slot's
 * Virtual Network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Website Name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshots(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the source control configuration of an app.
 *
 * Gets the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSourceControl(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
 * to limit to manual integration; <code>false</code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * <code>true</code> to enable deployment rollback; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
 * Mercurial repository; <code>false</code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * @summary Deletes the source control configuration of an app.
 *
 * Deletes the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSourceControl(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Starts an app (or deployment slot, if specified).
 *
 * Starts an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _start(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Stops an app (or deployment slot, if specified).
 *
 * Stops an app (or deployment slot, if specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _stop(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Sync web app repository.
 *
 * Sync web app repository.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _syncRepository(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] Return only information specified in the
 * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
 * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
 * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
 * duration'[Hour|Minute|Day]'.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsages(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + filter);
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the virtual networks the app (or deployment slot) is connected
 * to.
 *
 * Gets the virtual networks the app (or deployment slot) is connected to.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listVnetConnections(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'VnetInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'VnetInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets a virtual network the app (or deployment slot) is connected to
 * by name.
 *
 * Gets a virtual network the app (or deployment slot) is connected to by name.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnection(resourceGroupName, name, vnetName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Deletes a connection from an app (or deployment slot to a named
 * virtual network.
 *
 * Deletes a connection from an app (or deployment slot to a named virtual
 * network.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the virtual network.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteVnetConnection(resourceGroupName, name, vnetName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a Virtual Network connection to an app or slot (PUT) or
 * updates the connection properties (PATCH).
 *
 * Adds a Virtual Network connection to an app or slot (PUT) or updates the
 * connection properties (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of an existing Virtual Network.
 *
 * @param {object} connectionEnvelope Properties of the Virtual Network
 * connection. See example.
 *
 * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
 * resource ID.
 *
 * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
 * containing the public key of the private key used to authenticate a
 * Point-To-Site VPN connection.
 *
 * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
 * this Virtual Network. This should be a comma-separated list of IP addresses.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetInfo} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetInfo']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's Virtual Network gateway.
 *
 * Gets an app's Virtual Network gateway.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
 * (PATCH).
 *
 * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} vnetName Name of the Virtual Network.
 *
 * @param {string} gatewayName Name of the gateway. Currently, the only
 * supported string is "primary".
 *
 * @param {object} connectionEnvelope The properties to update this gateway
 * with.
 *
 * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
 *
 * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
 * package can be downloaded.
 *
 * @param {string} [connectionEnvelope.name] Resource Name.
 *
 * @param {string} [connectionEnvelope.kind] Kind of resource.
 *
 * @param {string} connectionEnvelope.location Resource Location.
 *
 * @param {string} [connectionEnvelope.type] Resource type.
 *
 * @param {object} [connectionEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VnetGateway} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (vnetName === null || vnetName === undefined || typeof vnetName.valueOf() !== 'string') {
      throw new Error('vnetName cannot be null or undefined and it must be of type string.');
    }
    if (gatewayName === null || gatewayName === undefined || typeof gatewayName.valueOf() !== 'string') {
      throw new Error('gatewayName cannot be null or undefined and it must be of type string.');
    }
    if (connectionEnvelope === null || connectionEnvelope === undefined) {
      throw new Error('connectionEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{vnetName}', encodeURIComponent(vnetName));
  requestUrl = requestUrl.replace('{gatewayName}', encodeURIComponent(gatewayName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (connectionEnvelope !== null && connectionEnvelope !== undefined) {
      let requestModelMapper = new client.models['VnetGateway']().mapper();
      requestModel = client.serialize(requestModelMapper, connectionEnvelope, 'connectionEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(connectionEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VnetGateway']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
 * enabled; otherwise, <code>false</code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
 * otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * <code>true</code> if request tracing is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * <code>true</code> if remote debugging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * <code>true</code> if detailed error logging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * <code>true</code> to use 32-bit worker process; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
 * Always On is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
 * if Auto Heal is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
 * default is <code>false</code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
 * enable client affinity; <code>false</code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is <code>true</code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, <code>false</code>. Default is <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
 * disable the public hostnames of the app; otherwise, <code>false</code>.
 * If <code>true</code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
 * overwrite destination app; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * <code>true</code> to clone custom hostnames from source app; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * <code>true</code> to clone source control from source app; otherwise,
 * <code>false</code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * <code>true</code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let skipDnsRegistration = (options && options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let skipCustomDomainVerification = (options && options.skipCustomDomainVerification !== undefined) ? options.skipCustomDomainVerification : undefined;
  let forceDnsRegistration = (options && options.forceDnsRegistration !== undefined) ? options.forceDnsRegistration : undefined;
  let ttlInSeconds = (options && options.ttlInSeconds !== undefined) ? options.ttlInSeconds : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteEnvelope === null || siteEnvelope === undefined) {
      throw new Error('siteEnvelope cannot be null or undefined.');
    }
    if (skipDnsRegistration !== null && skipDnsRegistration !== undefined && typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (skipCustomDomainVerification !== null && skipCustomDomainVerification !== undefined && typeof skipCustomDomainVerification !== 'boolean') {
      throw new Error('skipCustomDomainVerification must be of type boolean.');
    }
    if (forceDnsRegistration !== null && forceDnsRegistration !== undefined && typeof forceDnsRegistration !== 'boolean') {
      throw new Error('forceDnsRegistration must be of type boolean.');
    }
    if (ttlInSeconds !== null && ttlInSeconds !== undefined && typeof ttlInSeconds.valueOf() !== 'string') {
      throw new Error('ttlInSeconds must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (skipDnsRegistration !== null && skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  if (skipCustomDomainVerification !== null && skipCustomDomainVerification !== undefined) {
    queryParameters.push('skipCustomDomainVerification=' + encodeURIComponent(skipCustomDomainVerification.toString()));
  }
  if (forceDnsRegistration !== null && forceDnsRegistration !== undefined) {
    queryParameters.push('forceDnsRegistration=' + encodeURIComponent(forceDnsRegistration.toString()));
  }
  if (ttlInSeconds !== null && ttlInSeconds !== undefined) {
    queryParameters.push('ttlInSeconds=' + encodeURIComponent(ttlInSeconds));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteEnvelope !== null && siteEnvelope !== undefined) {
      let requestModelMapper = new client.models['Site']().mapper();
      requestModel = client.serialize(requestModelMapper, siteEnvelope, 'siteEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRestore(resourceGroupName, name, backupId, request, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginListPublishingCredentials(resourceGroupName, name, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a web app.
 *
 * Restores a web app.
 *
 * @param {string} subscriptionName Azure subscription
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationOptions Migration migrationOptions
 *
 * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
 * connection string.
 *
 * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
 *
 * @param {boolean} [migrationOptions.switchSiteAfterMigration]
 * <code>true</code>if the app should be switched over; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
 * if the app should be read only during copy operation; otherwise,
 * <code>false</code>.
 *
 * @param {string} [migrationOptions.name] Resource Name.
 *
 * @param {string} [migrationOptions.kind] Kind of resource.
 *
 * @param {string} migrationOptions.location Resource Location.
 *
 * @param {string} [migrationOptions.type] Resource type.
 *
 * @param {object} [migrationOptions.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link StorageMigrationResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (subscriptionName === null || subscriptionName === undefined || typeof subscriptionName.valueOf() !== 'string') {
      throw new Error('subscriptionName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (migrationOptions === null || migrationOptions === undefined) {
      throw new Error('migrationOptions cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('subscriptionName=' + encodeURIComponent(subscriptionName));
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (migrationOptions !== null && migrationOptions !== undefined) {
      let requestModelMapper = new client.models['StorageMigrationOptions']().mapper();
      requestModel = client.serialize(requestModelMapper, migrationOptions, 'migrationOptions');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(migrationOptions, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['StorageMigrationResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Migrates a local (in-app) MySql database to a remote MySql
 * database.
 *
 * Migrates a local (in-app) MySql database to a remote MySql database.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} migrationRequestEnvelope MySql migration options
 *
 * @param {string} [migrationRequestEnvelope.connectionString] Connection
 * string to the remote MySQL database to which data should be migrated.
 *
 * @param {string} [migrationRequestEnvelope.name] Resource Name.
 *
 * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
 *
 * @param {string} migrationRequestEnvelope.location Resource Location.
 *
 * @param {string} [migrationRequestEnvelope.type] Resource type.
 *
 * @param {object} [migrationRequestEnvelope.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Operation} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (migrationRequestEnvelope === null || migrationRequestEnvelope === undefined) {
      throw new Error('migrationRequestEnvelope cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (migrationRequestEnvelope !== null && migrationRequestEnvelope !== undefined) {
      let requestModelMapper = new client.models['MigrateMySqlRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, migrationRequestEnvelope, 'migrationRequestEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(migrationRequestEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Operation']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRecover(resourceGroupName, name, recoveryEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (recoveryEntity === null || recoveryEntity === undefined) {
      throw new Error('recoveryEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (recoveryEntity !== null && recoveryEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSiteRecoveryEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, recoveryEntity, 'recoveryEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(recoveryEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Creates a new web, mobile, or API app in an existing resource
 * group, or updates an existing app.
 *
 * Creates a new web, mobile, or API app in an existing resource group, or
 * updates an existing app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Unique name of the app to create or update. To create
 * or update a deployment slot, use the {slot} parameter.
 *
 * @param {object} siteEnvelope A JSON representation of the app properties.
 * See example.
 *
 * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
 * enabled; otherwise, <code>false</code>. Setting this value to false disables
 * the app (takes the app offline).
 *
 * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
 * to manage the SSL bindings for app's hostnames.
 *
 * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
 * App Service plan, formatted as:
 * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
 *
 * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
 * otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
 *
 * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
 *
 * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
 *
 * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
 * version.
 *
 * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
 *
 * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
 *
 * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
 *
 * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
 * and version
 *
 * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
 * <code>true</code> if request tracing is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
 * tracing expiration time.
 *
 * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
 * <code>true</code> if remote debugging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
 * debugging version.
 *
 * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
 * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
 *
 * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
 * directory size limit.
 *
 * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
 * <code>true</code> if detailed error logging is enabled; otherwise,
 * <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
 * name.
 *
 * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
 *
 * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
 * strings.
 *
 * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
 *
 * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
 *
 * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
 * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
 * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
 * 'OneDrive', 'VSO'
 *
 * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
 * <code>true</code> to use 32-bit worker process; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
 * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
 * Always On is enabled; otherwise, <code>false</code>.
 *
 * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
 *
 * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
 * container version.
 *
 * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
 * launch.
 *
 * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
 * pipeline mode. Possible values include: 'Integrated', 'Classic'
 *
 * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
 * applications.
 *
 * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
 * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
 * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
 *
 * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
 * for polymophic types.
 *
 * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
 * ramp-up rules.
 *
 * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
 * allowed CPU usage percentage.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
 * allowed memory usage in MB.
 *
 * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
 * allowed disk size usage in MB.
 *
 * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
 * if Auto Heal is enabled; otherwise, <code>false</code>.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
 * that describe when to execute the auto-heal actions.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
 * rule based on total requests.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
 * interval.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
 * based on private bytes.
 *
 * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
 * A rule based on status codes.
 *
 * @param {object}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
 * on request execution time.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
 * taken.
 *
 * @param {number}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
 * Time interval.
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
 * be executed when a rule is triggered.
 *
 * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
 * Predefined action to be taken. Possible values include: 'Recycle',
 * 'LogEvent', 'CustomAction'
 *
 * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
 * Custom action to be taken.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
 * to be run.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
 * Parameters for the executable.
 *
 * @param {string}
 * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
 * Minimum time the process must execute
 * before taking the action
 *
 * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
 *
 * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
 *
 * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
 * (CORS) settings.
 *
 * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
 * the list of origins that should be allowed to make cross-origin
 * calls (for example: http://example.com:12345). Use "*" to allow all.
 *
 * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
 *
 * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
 * flag indicating whether the Push endpoint is enabled.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
 * a JSON string containing a list of tags that are whitelisted for use by the
 * push registration endpoint.
 *
 * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
 * sets a JSON string containing a list of tags that require user
 * authentication to be used in the push registration endpoint.
 * Tags can consist of alphanumeric characters and the following:
 * '_', '@', '#', '.', ':', '-'.
 * Validation should be performed at the PushRequestHandler.
 *
 * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
 * a JSON string containing a list of dynamic tags that will be evaluated from
 * user claims in the push registration endpoint.
 *
 * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
 * the formal API definition for the app.
 *
 * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
 * API definition.
 *
 * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
 * name.
 *
 * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
 * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
 *
 * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
 * restrictions.
 *
 * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
 * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
 * default is <code>false</code>.
 *
 * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
 * Environment to use for the app.
 *
 * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
 * the App Service Environment.
 *
 * @param {string} [siteEnvelope.microService] Micro services like apps, logic
 * apps.
 *
 * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
 * associated with the app.
 *
 * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
 * enable client affinity; <code>false</code> to stop sending session affinity
 * cookies, which route client requests in the same session to the same
 * instance. Default is <code>true</code>.
 *
 * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
 * enable client certificate authentication (TLS mutual authentication);
 * otherwise, <code>false</code>. Default is <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
 * disable the public hostnames of the app; otherwise, <code>false</code>.
 * If <code>true</code>, the app is only accessible via API management process.
 *
 * @param {number} [siteEnvelope.containerSize] Size of the function container.
 *
 * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
 * memory-time quota (applicable on dynamic apps only).
 *
 * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
 * the app is cloned from a source app.
 *
 * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
 * cloning operation. This ID ties multiple cloning operations
 * together to use the same snapshot.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
 * overwrite destination app; otherwise, <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
 * <code>true</code> to clone custom hostnames from source app; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
 * <code>true</code> to clone source control from source app; otherwise,
 * <code>false</code>.
 *
 * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
 * the source app. App resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
 * for production slots and
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
 * for other slots.
 *
 * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
 * Environment.
 *
 * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
 * setting overrides for cloned app. If specified, these settings override the
 * settings cloned
 * from source app. Otherwise, application settings from source app are
 * retained.
 *
 * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
 * <code>true</code> to configure load balancing for source and destination
 * app.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
 * resource ID of the Traffic Manager profile to use, if it exists. Traffic
 * Manager resource ID is of the form
 * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
 *
 * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
 * Traffic Manager profile to create. This is only needed if Traffic Manager
 * profile does not already exist.
 *
 * @param {string} [siteEnvelope.name] Resource Name.
 *
 * @param {string} [siteEnvelope.kind] Kind of resource.
 *
 * @param {string} siteEnvelope.location Resource Location.
 *
 * @param {string} [siteEnvelope.type] Resource type.
 *
 * @param {object} [siteEnvelope.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot to create or update. By
 * default, this API attempts to create or modify the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
 * not registered with DNS on creation. This parameter is
 * only used for app creation
 *
 * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
 * *.azurewebsites.net) domains associated with web app are not verified.
 *
 * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
 * force registered with DNS
 *
 * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
 * default domain name
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Site} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let skipDnsRegistration = (options && options.skipDnsRegistration !== undefined) ? options.skipDnsRegistration : undefined;
  let skipCustomDomainVerification = (options && options.skipCustomDomainVerification !== undefined) ? options.skipCustomDomainVerification : undefined;
  let forceDnsRegistration = (options && options.forceDnsRegistration !== undefined) ? options.forceDnsRegistration : undefined;
  let ttlInSeconds = (options && options.ttlInSeconds !== undefined) ? options.ttlInSeconds : undefined;
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteEnvelope === null || siteEnvelope === undefined) {
      throw new Error('siteEnvelope cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (skipDnsRegistration !== null && skipDnsRegistration !== undefined && typeof skipDnsRegistration !== 'boolean') {
      throw new Error('skipDnsRegistration must be of type boolean.');
    }
    if (skipCustomDomainVerification !== null && skipCustomDomainVerification !== undefined && typeof skipCustomDomainVerification !== 'boolean') {
      throw new Error('skipCustomDomainVerification must be of type boolean.');
    }
    if (forceDnsRegistration !== null && forceDnsRegistration !== undefined && typeof forceDnsRegistration !== 'boolean') {
      throw new Error('forceDnsRegistration must be of type boolean.');
    }
    if (ttlInSeconds !== null && ttlInSeconds !== undefined && typeof ttlInSeconds.valueOf() !== 'string') {
      throw new Error('ttlInSeconds must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  if (skipDnsRegistration !== null && skipDnsRegistration !== undefined) {
    queryParameters.push('skipDnsRegistration=' + encodeURIComponent(skipDnsRegistration.toString()));
  }
  if (skipCustomDomainVerification !== null && skipCustomDomainVerification !== undefined) {
    queryParameters.push('skipCustomDomainVerification=' + encodeURIComponent(skipCustomDomainVerification.toString()));
  }
  if (forceDnsRegistration !== null && forceDnsRegistration !== undefined) {
    queryParameters.push('forceDnsRegistration=' + encodeURIComponent(forceDnsRegistration.toString()));
  }
  if (ttlInSeconds !== null && ttlInSeconds !== undefined) {
    queryParameters.push('ttlInSeconds=' + encodeURIComponent(ttlInSeconds));
  }
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteEnvelope !== null && siteEnvelope !== undefined) {
      let requestModelMapper = new client.models['Site']().mapper();
      requestModel = client.serialize(requestModelMapper, siteEnvelope, 'siteEnvelope');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteEnvelope, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Site']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * Restores a specific backup to another app (or deployment slot, if
 * specified).
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} backupId ID of the backup.
 *
 * @param {object} request Information on restore request
 *
 * @param {string} [request.storageAccountUrl] SAS URL to the container.
 *
 * @param {string} [request.blobName] Name of a blob which contains the backup.
 *
 * @param {boolean} [request.overwrite] <code>true</code> if the restore
 * operation can overwrite target app; otherwise, <code>false</code>.
 * <code>true</code> is needed if trying to restore over an existing app.
 *
 * @param {string} [request.siteName] Name of an app.
 *
 * @param {array} [request.databases] Collection of databases which should be
 * restored. This list has to match the list of databases included in the
 * backup.
 *
 * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
 * restoring an app with custom domains. <code>true</code> to remove custom
 * domains automatically. If <code>false</code>, custom domains are added to
 * the app's object when it is being restored, but that might fail due to
 * conflicts during the operation.
 *
 * @param {string} [request.operationType] Operation type. Possible values
 * include: 'Default', 'Clone', 'Relocation'
 *
 * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
 * SiteConfig.ConnectionStrings should be set in new app; otherwise,
 * <code>false</code>.
 *
 * @param {string} [request.hostingEnvironment] App Service Environment name,
 * if needed (only when restoring an app to an App Service Environment).
 *
 * @param {string} [request.name] Resource Name.
 *
 * @param {string} [request.kind] Kind of resource.
 *
 * @param {string} request.location Resource Location.
 *
 * @param {string} [request.type] Resource type.
 *
 * @param {object} [request.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will restore a backup of the production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RestoreResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (backupId === null || backupId === undefined || typeof backupId.valueOf() !== 'string') {
      throw new Error('backupId cannot be null or undefined and it must be of type string.');
    }
    if (request === null || request === undefined) {
      throw new Error('request cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{backupId}', encodeURIComponent(backupId));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (request !== null && request !== undefined) {
      let requestModelMapper = new client.models['RestoreRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, request, 'request');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(request, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RestoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the Git/FTP publishing credentials of an app.
 *
 * Gets the Git/FTP publishing credentials of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will get the publishing credentials for the production
 * slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Recovers a deleted web app.
 *
 * Recovers a deleted web app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of web app
 *
 * @param {object} recoveryEntity Snapshot data used for web app recovery.
 * Snapshot information can be obtained by calling GetDeletedSites or
 * GetSiteSnapshots API.
 *
 * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
 * recovery should be attempted.
 *
 * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
 * into which app should be recovered. This is case when new app should be
 * created instead.
 *
 * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
 * name into which app should be recovered.
 *
 * @param {string} slot Name of web app slot. If not specified then will
 * default to production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RecoverResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (recoveryEntity === null || recoveryEntity === undefined) {
      throw new Error('recoveryEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (recoveryEntity !== null && recoveryEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSiteRecoveryEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, recoveryEntity, 'recoveryEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(recoveryEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RecoverResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {string} slot Name of the source slot. If a slot is not specified,
 * the production slot is used as the source slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
 * to limit to manual integration; <code>false</code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * <code>true</code> to enable deployment rollback; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
 * Mercurial repository; <code>false</code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {string} slot Name of the deployment slot. If a slot is not
 * specified, the API will update the source control configuration for the
 * production slot.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteSourceControl === null || siteSourceControl === undefined) {
      throw new Error('siteSourceControl cannot be null or undefined.');
    }
    if (slot === null || slot === undefined || typeof slot.valueOf() !== 'string') {
      throw new Error('slot cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{slot}', encodeURIComponent(slot));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteSourceControl !== null && siteSourceControl !== undefined) {
      let requestModelMapper = new client.models['SiteSourceControl']().mapper();
      requestModel = client.serialize(requestModelMapper, siteSourceControl, 'siteSourceControl');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteSourceControl, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Swaps two deployment slots of an app.
 *
 * Swaps two deployment slots of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} slotSwapEntity JSON object that contains the target slot
 * name. See example.
 *
 * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
 * swap operation.
 *
 * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
 * Virtual Network to the slot during swap; otherwise, <code>false</code>.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (slotSwapEntity === null || slotSwapEntity === undefined) {
      throw new Error('slotSwapEntity cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (slotSwapEntity !== null && slotSwapEntity !== undefined) {
      let requestModelMapper = new client.models['CsmSlotEntity']().mapper();
      requestModel = client.serialize(requestModelMapper, slotSwapEntity, 'slotSwapEntity');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(slotSwapEntity, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Updates the source control configuration of an app.
 *
 * Updates the source control configuration of an app.
 *
 * @param {string} resourceGroupName Name of the resource group to which the
 * resource belongs.
 *
 * @param {string} name Name of the app.
 *
 * @param {object} siteSourceControl JSON representation of a SiteSourceControl
 * object. See example.
 *
 * @param {string} [siteSourceControl.repoUrl] Repository or source control
 * URL.
 *
 * @param {string} [siteSourceControl.branch] Name of branch to use for
 * deployment.
 *
 * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
 * to limit to manual integration; <code>false</code> to enable continuous
 * integration (which configures webhooks into online repos like GitHub).
 *
 * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
 * <code>true</code> to enable deployment rollback; otherwise,
 * <code>false</code>.
 *
 * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
 * Mercurial repository; <code>false</code> for a Git repository.
 *
 * @param {string} [siteSourceControl.name] Resource Name.
 *
 * @param {string} [siteSourceControl.kind] Kind of resource.
 *
 * @param {string} siteSourceControl.location Resource Location.
 *
 * @param {string} [siteSourceControl.type] Resource type.
 *
 * @param {object} [siteSourceControl.tags] Resource tags.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SiteSourceControl} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let apiVersion = '2016-08-01';
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+[^\.]$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+[^\.]$/');
      }
    }
    if (name === null || name === undefined || typeof name.valueOf() !== 'string') {
      throw new Error('name cannot be null or undefined and it must be of type string.');
    }
    if (siteSourceControl === null || siteSourceControl === undefined) {
      throw new Error('siteSourceControl cannot be null or undefined.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{name}', encodeURIComponent(name));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (siteSourceControl !== null && siteSourceControl !== undefined) {
      let requestModelMapper = new client.models['SiteSourceControl']().mapper();
      requestModel = client.serialize(requestModelMapper, siteSourceControl, 'siteSourceControl');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(siteSourceControl, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 201) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SiteSourceControl']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get all apps for a subscription.
 *
 * Get all apps for a subscription.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all web, mobile, and API apps in the specified resource group.
 *
 * Gets all web, mobile, and API apps in the specified resource group.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByResourceGroupNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets an app's deployment slots.
 *
 * Gets an app's deployment slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets existing backups of an app.
 *
 * Gets existing backups of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link BackupItemCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listBackupsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['BackupItemCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDeploymentsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Lists ownership identifiers for domain associated with web app.
 *
 * Lists ownership identifiers for domain associated with web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link IdentifierCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IdentifierCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get hostname bindings for an app or a deployment slot.
 *
 * Get hostname bindings for an app or a deployment slot.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link HostNameBindingCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listHostNameBindingsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['HostNameBindingCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all scale-out instances of an app.
 *
 * Gets all scale-out instances of an app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link WebAppInstanceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceIdentifiersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WebAppInstanceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary List deployments for an app, or a deployment slot, or for an
 * instance of a scaled-out app.
 *
 * List deployments for an app, or a deployment slot, or for an instance of a
 * scaled-out app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DeploymentCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listInstanceDeploymentsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeploymentCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets all metric definitions of an app (or deployment slot, if
 * specified).
 *
 * Gets all metric definitions of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricDefinitionCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitionsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricDefinitionCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets performance metrics of an app (or deployment slot, if
 * specified).
 *
 * Gets performance metrics of an app (or deployment slot, if specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link ResourceMetricCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ResourceMetricCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets perfmon counters for web app.
 *
 * Gets perfmon counters for web app.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link PerfMonCounterCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listPerfMonCountersSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['PerfMonCounterCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesSlotNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Get the difference in configuration settings between two web app
 * slots.
 *
 * Get the difference in configuration settings between two web app slots.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SlotDifferenceCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSlotDifferencesFromProductionNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SlotDifferenceCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Returns all Snapshots to the user.
 *
 * Returns all Snapshots to the user.
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SnapshotCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSnapshotsNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SnapshotCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * Gets the quota usage information of an app (or deployment slot, if
 * specified).
 *
 * @param {string} nextPageLink The NextLink from the previous successful call
 * to List operation.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CsmUsageQuotaCollection} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsagesNext(nextPageLink, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (nextPageLink === null || nextPageLink === undefined || typeof nextPageLink.valueOf() !== 'string') {
      throw new Error('nextPageLink cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let requestUrl = '{nextLink}';
  requestUrl = requestUrl.replace('{nextLink}', nextPageLink);

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CsmUsageQuotaCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @class
 * WebApps
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the WebSiteManagementClient.
 * Initializes a new instance of the WebApps class.
 * @constructor
 *
 * @param {WebSiteManagementClient} client Reference to the service client.
 */
class WebApps {
  constructor(client) {
    this.client = client;
    this._list = _list;
    this._listByResourceGroup = _listByResourceGroup;
    this._get = _get;
    this._createOrUpdate = _createOrUpdate;
    this._deleteMethod = _deleteMethod;
    this._analyzeCustomHostname = _analyzeCustomHostname;
    this._applySlotConfigToProduction = _applySlotConfigToProduction;
    this._backup = _backup;
    this._listBackups = _listBackups;
    this._discoverRestore = _discoverRestore;
    this._getBackupStatus = _getBackupStatus;
    this._deleteBackup = _deleteBackup;
    this._listBackupStatusSecrets = _listBackupStatusSecrets;
    this._restore = _restore;
    this._updateApplicationSettings = _updateApplicationSettings;
    this._listApplicationSettings = _listApplicationSettings;
    this._updateAuthSettings = _updateAuthSettings;
    this._getAuthSettings = _getAuthSettings;
    this._updateBackupConfiguration = _updateBackupConfiguration;
    this._deleteBackupConfiguration = _deleteBackupConfiguration;
    this._getBackupConfiguration = _getBackupConfiguration;
    this._updateConnectionStrings = _updateConnectionStrings;
    this._listConnectionStrings = _listConnectionStrings;
    this._getDiagnosticLogsConfiguration = _getDiagnosticLogsConfiguration;
    this._updateDiagnosticLogsConfig = _updateDiagnosticLogsConfig;
    this._updateMetadata = _updateMetadata;
    this._listMetadata = _listMetadata;
    this._listPublishingCredentials = _listPublishingCredentials;
    this._updateSitePushSettings = _updateSitePushSettings;
    this._listSitePushSettings = _listSitePushSettings;
    this._listSlotConfigurationNames = _listSlotConfigurationNames;
    this._updateSlotConfigurationNames = _updateSlotConfigurationNames;
    this._getConfiguration = _getConfiguration;
    this._createOrUpdateConfiguration = _createOrUpdateConfiguration;
    this._updateConfiguration = _updateConfiguration;
    this._listConfigurationSnapshotInfo = _listConfigurationSnapshotInfo;
    this._getConfigurationSnapshot = _getConfigurationSnapshot;
    this._recoverSiteConfigurationSnapshot = _recoverSiteConfigurationSnapshot;
    this._listDeployments = _listDeployments;
    this._getDeployment = _getDeployment;
    this._createDeployment = _createDeployment;
    this._deleteDeployment = _deleteDeployment;
    this._listDomainOwnershipIdentifiers = _listDomainOwnershipIdentifiers;
    this._getDomainOwnershipIdentifier = _getDomainOwnershipIdentifier;
    this._createOrUpdateDomainOwnershipIdentifier = _createOrUpdateDomainOwnershipIdentifier;
    this._deleteDomainOwnershipIdentifier = _deleteDomainOwnershipIdentifier;
    this._updateDomainOwnershipIdentifier = _updateDomainOwnershipIdentifier;
    this._listHostNameBindings = _listHostNameBindings;
    this._getHostNameBinding = _getHostNameBinding;
    this._createOrUpdateHostNameBinding = _createOrUpdateHostNameBinding;
    this._deleteHostNameBinding = _deleteHostNameBinding;
    this._getHybridConnection = _getHybridConnection;
    this._createOrUpdateHybridConnection = _createOrUpdateHybridConnection;
    this._deleteHybridConnection = _deleteHybridConnection;
    this._updateHybridConnection = _updateHybridConnection;
    this._listHybridConnectionKeys = _listHybridConnectionKeys;
    this._listHybridConnections = _listHybridConnections;
    this._listRelayServiceConnections = _listRelayServiceConnections;
    this._getRelayServiceConnection = _getRelayServiceConnection;
    this._createOrUpdateRelayServiceConnection = _createOrUpdateRelayServiceConnection;
    this._deleteRelayServiceConnection = _deleteRelayServiceConnection;
    this._updateRelayServiceConnection = _updateRelayServiceConnection;
    this._listInstanceIdentifiers = _listInstanceIdentifiers;
    this._listInstanceDeployments = _listInstanceDeployments;
    this._getInstanceDeployment = _getInstanceDeployment;
    this._createInstanceDeployment = _createInstanceDeployment;
    this._deleteInstanceDeployment = _deleteInstanceDeployment;
    this._isCloneable = _isCloneable;
    this._listMetricDefinitions = _listMetricDefinitions;
    this._listMetrics = _listMetrics;
    this._migrateStorage = _migrateStorage;
    this._migrateMySql = _migrateMySql;
    this._getMigrateMySqlStatus = _getMigrateMySqlStatus;
    this._listNetworkFeatures = _listNetworkFeatures;
    this._startWebSiteNetworkTrace = _startWebSiteNetworkTrace;
    this._stopWebSiteNetworkTrace = _stopWebSiteNetworkTrace;
    this._generateNewSitePublishingPassword = _generateNewSitePublishingPassword;
    this._listPerfMonCounters = _listPerfMonCounters;
    this._getSitePhpErrorLogFlag = _getSitePhpErrorLogFlag;
    this._listPremierAddOns = _listPremierAddOns;
    this._getPremierAddOn = _getPremierAddOn;
    this._addPremierAddOn = _addPremierAddOn;
    this._deletePremierAddOn = _deletePremierAddOn;
    this._listPublishingProfileXmlWithSecrets = _listPublishingProfileXmlWithSecrets;
    this._recover = _recover;
    this._resetProductionSlotConfig = _resetProductionSlotConfig;
    this._restart = _restart;
    this._listSlots = _listSlots;
    this._getSlot = _getSlot;
    this._createOrUpdateSlot = _createOrUpdateSlot;
    this._deleteSlot = _deleteSlot;
    this._analyzeCustomHostnameSlot = _analyzeCustomHostnameSlot;
    this._applySlotConfigurationSlot = _applySlotConfigurationSlot;
    this._backupSlot = _backupSlot;
    this._listBackupsSlot = _listBackupsSlot;
    this._discoverRestoreSlot = _discoverRestoreSlot;
    this._getBackupStatusSlot = _getBackupStatusSlot;
    this._deleteBackupSlot = _deleteBackupSlot;
    this._listBackupStatusSecretsSlot = _listBackupStatusSecretsSlot;
    this._restoreSlot = _restoreSlot;
    this._updateApplicationSettingsSlot = _updateApplicationSettingsSlot;
    this._listApplicationSettingsSlot = _listApplicationSettingsSlot;
    this._updateAuthSettingsSlot = _updateAuthSettingsSlot;
    this._getAuthSettingsSlot = _getAuthSettingsSlot;
    this._updateBackupConfigurationSlot = _updateBackupConfigurationSlot;
    this._deleteBackupConfigurationSlot = _deleteBackupConfigurationSlot;
    this._getBackupConfigurationSlot = _getBackupConfigurationSlot;
    this._updateConnectionStringsSlot = _updateConnectionStringsSlot;
    this._listConnectionStringsSlot = _listConnectionStringsSlot;
    this._getDiagnosticLogsConfigurationSlot = _getDiagnosticLogsConfigurationSlot;
    this._updateDiagnosticLogsConfigSlot = _updateDiagnosticLogsConfigSlot;
    this._updateMetadataSlot = _updateMetadataSlot;
    this._listMetadataSlot = _listMetadataSlot;
    this._listPublishingCredentialsSlot = _listPublishingCredentialsSlot;
    this._updateSitePushSettingsSlot = _updateSitePushSettingsSlot;
    this._listSitePushSettingsSlot = _listSitePushSettingsSlot;
    this._getConfigurationSlot = _getConfigurationSlot;
    this._createOrUpdateConfigurationSlot = _createOrUpdateConfigurationSlot;
    this._updateConfigurationSlot = _updateConfigurationSlot;
    this._listConfigurationSnapshotInfoSlot = _listConfigurationSnapshotInfoSlot;
    this._getConfigurationSnapshotSlot = _getConfigurationSnapshotSlot;
    this._recoverSiteConfigurationSnapshotSlot = _recoverSiteConfigurationSnapshotSlot;
    this._listDeploymentsSlot = _listDeploymentsSlot;
    this._getDeploymentSlot = _getDeploymentSlot;
    this._createDeploymentSlot = _createDeploymentSlot;
    this._deleteDeploymentSlot = _deleteDeploymentSlot;
    this._listDomainOwnershipIdentifiersSlot = _listDomainOwnershipIdentifiersSlot;
    this._getDomainOwnershipIdentifierSlot = _getDomainOwnershipIdentifierSlot;
    this._createOrUpdateDomainOwnershipIdentifierSlot = _createOrUpdateDomainOwnershipIdentifierSlot;
    this._deleteDomainOwnershipIdentifierSlot = _deleteDomainOwnershipIdentifierSlot;
    this._updateDomainOwnershipIdentifierSlot = _updateDomainOwnershipIdentifierSlot;
    this._listHostNameBindingsSlot = _listHostNameBindingsSlot;
    this._getHostNameBindingSlot = _getHostNameBindingSlot;
    this._createOrUpdateHostNameBindingSlot = _createOrUpdateHostNameBindingSlot;
    this._deleteHostNameBindingSlot = _deleteHostNameBindingSlot;
    this._getHybridConnectionSlot = _getHybridConnectionSlot;
    this._createOrUpdateHybridConnectionSlot = _createOrUpdateHybridConnectionSlot;
    this._deleteHybridConnectionSlot = _deleteHybridConnectionSlot;
    this._updateHybridConnectionSlot = _updateHybridConnectionSlot;
    this._listHybridConnectionKeysSlot = _listHybridConnectionKeysSlot;
    this._listHybridConnectionsSlot = _listHybridConnectionsSlot;
    this._listRelayServiceConnectionsSlot = _listRelayServiceConnectionsSlot;
    this._getRelayServiceConnectionSlot = _getRelayServiceConnectionSlot;
    this._createOrUpdateRelayServiceConnectionSlot = _createOrUpdateRelayServiceConnectionSlot;
    this._deleteRelayServiceConnectionSlot = _deleteRelayServiceConnectionSlot;
    this._updateRelayServiceConnectionSlot = _updateRelayServiceConnectionSlot;
    this._listInstanceIdentifiersSlot = _listInstanceIdentifiersSlot;
    this._listInstanceDeploymentsSlot = _listInstanceDeploymentsSlot;
    this._getInstanceDeploymentSlot = _getInstanceDeploymentSlot;
    this._createInstanceDeploymentSlot = _createInstanceDeploymentSlot;
    this._deleteInstanceDeploymentSlot = _deleteInstanceDeploymentSlot;
    this._isCloneableSlot = _isCloneableSlot;
    this._listMetricDefinitionsSlot = _listMetricDefinitionsSlot;
    this._listMetricsSlot = _listMetricsSlot;
    this._getMigrateMySqlStatusSlot = _getMigrateMySqlStatusSlot;
    this._listNetworkFeaturesSlot = _listNetworkFeaturesSlot;
    this._startWebSiteNetworkTraceSlot = _startWebSiteNetworkTraceSlot;
    this._stopWebSiteNetworkTraceSlot = _stopWebSiteNetworkTraceSlot;
    this._generateNewSitePublishingPasswordSlot = _generateNewSitePublishingPasswordSlot;
    this._listPerfMonCountersSlot = _listPerfMonCountersSlot;
    this._getSitePhpErrorLogFlagSlot = _getSitePhpErrorLogFlagSlot;
    this._listPremierAddOnsSlot = _listPremierAddOnsSlot;
    this._getPremierAddOnSlot = _getPremierAddOnSlot;
    this._addPremierAddOnSlot = _addPremierAddOnSlot;
    this._deletePremierAddOnSlot = _deletePremierAddOnSlot;
    this._listPublishingProfileXmlWithSecretsSlot = _listPublishingProfileXmlWithSecretsSlot;
    this._recoverSlot = _recoverSlot;
    this._resetSlotConfigurationSlot = _resetSlotConfigurationSlot;
    this._restartSlot = _restartSlot;
    this._listSlotDifferencesSlot = _listSlotDifferencesSlot;
    this._swapSlotSlot = _swapSlotSlot;
    this._listSnapshotsSlot = _listSnapshotsSlot;
    this._getSourceControlSlot = _getSourceControlSlot;
    this._createOrUpdateSourceControlSlot = _createOrUpdateSourceControlSlot;
    this._deleteSourceControlSlot = _deleteSourceControlSlot;
    this._startSlot = _startSlot;
    this._stopSlot = _stopSlot;
    this._syncRepositorySlot = _syncRepositorySlot;
    this._listUsagesSlot = _listUsagesSlot;
    this._listVnetConnectionsSlot = _listVnetConnectionsSlot;
    this._getVnetConnectionSlot = _getVnetConnectionSlot;
    this._createOrUpdateVnetConnectionSlot = _createOrUpdateVnetConnectionSlot;
    this._deleteVnetConnectionSlot = _deleteVnetConnectionSlot;
    this._updateVnetConnectionSlot = _updateVnetConnectionSlot;
    this._getVnetConnectionGatewaySlot = _getVnetConnectionGatewaySlot;
    this._createOrUpdateVnetConnectionGatewaySlot = _createOrUpdateVnetConnectionGatewaySlot;
    this._updateVnetConnectionGatewaySlot = _updateVnetConnectionGatewaySlot;
    this._listSlotDifferencesFromProduction = _listSlotDifferencesFromProduction;
    this._swapSlotWithProduction = _swapSlotWithProduction;
    this._listSnapshots = _listSnapshots;
    this._getSourceControl = _getSourceControl;
    this._createOrUpdateSourceControl = _createOrUpdateSourceControl;
    this._deleteSourceControl = _deleteSourceControl;
    this._start = _start;
    this._stop = _stop;
    this._syncRepository = _syncRepository;
    this._listUsages = _listUsages;
    this._listVnetConnections = _listVnetConnections;
    this._getVnetConnection = _getVnetConnection;
    this._createOrUpdateVnetConnection = _createOrUpdateVnetConnection;
    this._deleteVnetConnection = _deleteVnetConnection;
    this._updateVnetConnection = _updateVnetConnection;
    this._getVnetConnectionGateway = _getVnetConnectionGateway;
    this._createOrUpdateVnetConnectionGateway = _createOrUpdateVnetConnectionGateway;
    this._updateVnetConnectionGateway = _updateVnetConnectionGateway;
    this._beginCreateOrUpdate = _beginCreateOrUpdate;
    this._beginRestore = _beginRestore;
    this._beginListPublishingCredentials = _beginListPublishingCredentials;
    this._beginMigrateStorage = _beginMigrateStorage;
    this._beginMigrateMySql = _beginMigrateMySql;
    this._beginRecover = _beginRecover;
    this._beginCreateOrUpdateSlot = _beginCreateOrUpdateSlot;
    this._beginRestoreSlot = _beginRestoreSlot;
    this._beginListPublishingCredentialsSlot = _beginListPublishingCredentialsSlot;
    this._beginRecoverSlot = _beginRecoverSlot;
    this._beginSwapSlotSlot = _beginSwapSlotSlot;
    this._beginCreateOrUpdateSourceControlSlot = _beginCreateOrUpdateSourceControlSlot;
    this._beginSwapSlotWithProduction = _beginSwapSlotWithProduction;
    this._beginCreateOrUpdateSourceControl = _beginCreateOrUpdateSourceControl;
    this._listNext = _listNext;
    this._listByResourceGroupNext = _listByResourceGroupNext;
    this._listBackupsNext = _listBackupsNext;
    this._listDeploymentsNext = _listDeploymentsNext;
    this._listDomainOwnershipIdentifiersNext = _listDomainOwnershipIdentifiersNext;
    this._listHostNameBindingsNext = _listHostNameBindingsNext;
    this._listInstanceIdentifiersNext = _listInstanceIdentifiersNext;
    this._listInstanceDeploymentsNext = _listInstanceDeploymentsNext;
    this._listMetricDefinitionsNext = _listMetricDefinitionsNext;
    this._listMetricsNext = _listMetricsNext;
    this._listPerfMonCountersNext = _listPerfMonCountersNext;
    this._listSlotsNext = _listSlotsNext;
    this._listBackupsSlotNext = _listBackupsSlotNext;
    this._listDeploymentsSlotNext = _listDeploymentsSlotNext;
    this._listDomainOwnershipIdentifiersSlotNext = _listDomainOwnershipIdentifiersSlotNext;
    this._listHostNameBindingsSlotNext = _listHostNameBindingsSlotNext;
    this._listInstanceIdentifiersSlotNext = _listInstanceIdentifiersSlotNext;
    this._listInstanceDeploymentsSlotNext = _listInstanceDeploymentsSlotNext;
    this._listMetricDefinitionsSlotNext = _listMetricDefinitionsSlotNext;
    this._listMetricsSlotNext = _listMetricsSlotNext;
    this._listPerfMonCountersSlotNext = _listPerfMonCountersSlotNext;
    this._listSlotDifferencesSlotNext = _listSlotDifferencesSlotNext;
    this._listSnapshotsSlotNext = _listSnapshotsSlotNext;
    this._listUsagesSlotNext = _listUsagesSlotNext;
    this._listSlotDifferencesFromProductionNext = _listSlotDifferencesFromProductionNext;
    this._listSnapshotsNext = _listSnapshotsNext;
    this._listUsagesNext = _listUsagesNext;
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeSlots] Specify <strong>true</strong> to
   * include deployment slots in results. The default is false, which only gives
   * you the production slot of all apps.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByResourceGroupWithHttpOperationResponse(resourceGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeSlots] Specify <strong>true</strong> to
   * include deployment slots in results. The default is false, which only gives
   * you the production slot of all apps.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByResourceGroup(resourceGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByResourceGroup(resourceGroupName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CustomHostnameAnalysisResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  analyzeCustomHostnameWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._analyzeCustomHostname(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CustomHostnameAnalysisResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CustomHostnameAnalysisResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  analyzeCustomHostname(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._analyzeCustomHostname(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._analyzeCustomHostname(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  applySlotConfigToProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backup(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backup(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backup(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backup(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackups(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackups(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackups(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackups(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  discoverRestoreWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._discoverRestore(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  discoverRestore(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._discoverRestore(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._discoverRestore(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupStatusWithHttpOperationResponse(resourceGroupName, name, backupId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupStatus(resourceGroupName, name, backupId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupStatus(resourceGroupName, name, backupId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupStatus(resourceGroupName, name, backupId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupStatus(resourceGroupName, name, backupId, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupWithHttpOperationResponse(resourceGroupName, name, backupId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackup(resourceGroupName, name, backupId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackup(resourceGroupName, name, backupId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackup(resourceGroupName, name, backupId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackup(resourceGroupName, name, backupId, options, optionalCallback);
    }
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupStatusSecretsWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupStatusSecrets(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restore(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restore(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationSettingsWithHttpOperationResponse(resourceGroupName, name, appSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationSettings(resourceGroupName, name, appSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationSettings(resourceGroupName, name, appSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationSettings(resourceGroupName, name, appSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationSettings(resourceGroupName, name, appSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listApplicationSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listApplicationSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listApplicationSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listApplicationSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listApplicationSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, <code>false</code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, <code>false</code>.
   * The default is <code>false</code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the <code>ClientID</code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAuthSettingsWithHttpOperationResponse(resourceGroupName, name, siteAuthSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, <code>false</code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, <code>false</code>.
   * The default is <code>false</code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the <code>ClientID</code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAuthSettings(resourceGroupName, name, siteAuthSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAuthSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAuthSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAuthSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAuthSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAuthSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateBackupConfiguration(resourceGroupName, name, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupConfiguration(resourceGroupName, name, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateBackupConfiguration(resourceGroupName, name, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateBackupConfiguration(resourceGroupName, name, request, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConnectionStringsWithHttpOperationResponse(resourceGroupName, name, connectionStrings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConnectionStrings(resourceGroupName, name, connectionStrings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConnectionStrings(resourceGroupName, name, connectionStrings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConnectionStringsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConnectionStrings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConnectionStrings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConnectionStrings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConnectionStrings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDiagnosticLogsConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDiagnosticLogsConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDiagnosticLogsConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDiagnosticLogsConfigWithHttpOperationResponse(resourceGroupName, name, siteLogsConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateMetadataWithHttpOperationResponse(resourceGroupName, name, metadata, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateMetadata(resourceGroupName, name, metadata, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateMetadata(resourceGroupName, name, metadata, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateMetadata(resourceGroupName, name, metadata, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateMetadata(resourceGroupName, name, metadata, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetadataWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetadata(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetadata(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetadata(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetadata(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingCredentialsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingCredentials(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingCredentials(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSitePushSettingsWithHttpOperationResponse(resourceGroupName, name, pushSettings, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSitePushSettings(resourceGroupName, name, pushSettings, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSitePushSettings(resourceGroupName, name, pushSettings, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSitePushSettingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSitePushSettings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSitePushSettings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSitePushSettings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSitePushSettings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the names of app settings and connection strings that stick to
   * the slot (not swapped).
   *
   * Gets the names of app settings and connection strings that stick to the slot
   * (not swapped).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotConfigNamesResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotConfigurationNamesWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotConfigurationNames(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the names of app settings and connection strings that stick to
   * the slot (not swapped).
   *
   * Gets the names of app settings and connection strings that stick to the slot
   * (not swapped).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotConfigNamesResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotConfigNamesResource} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotConfigurationNames(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotConfigurationNames(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotConfigurationNames(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the names of application settings and connection string
   * that remain with the slot during swap operation.
   *
   * Updates the names of application settings and connection string that remain
   * with the slot during swap operation.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotConfigNames Names of application settings and connection
   * strings. See example.
   *
   * @param {array} [slotConfigNames.connectionStringNames] List of connection
   * string names.
   *
   * @param {array} [slotConfigNames.appSettingNames] List of application
   * settings names.
   *
   * @param {string} [slotConfigNames.name] Resource Name.
   *
   * @param {string} [slotConfigNames.kind] Kind of resource.
   *
   * @param {string} slotConfigNames.location Resource Location.
   *
   * @param {string} [slotConfigNames.type] Resource type.
   *
   * @param {object} [slotConfigNames.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotConfigNamesResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSlotConfigurationNamesWithHttpOperationResponse(resourceGroupName, name, slotConfigNames, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the names of application settings and connection string
   * that remain with the slot during swap operation.
   *
   * Updates the names of application settings and connection string that remain
   * with the slot during swap operation.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotConfigNames Names of application settings and connection
   * strings. See example.
   *
   * @param {array} [slotConfigNames.connectionStringNames] List of connection
   * string names.
   *
   * @param {array} [slotConfigNames.appSettingNames] List of application
   * settings names.
   *
   * @param {string} [slotConfigNames.name] Resource Name.
   *
   * @param {string} [slotConfigNames.kind] Kind of resource.
   *
   * @param {string} slotConfigNames.location Resource Location.
   *
   * @param {string} [slotConfigNames.type] Resource type.
   *
   * @param {object} [slotConfigNames.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotConfigNamesResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotConfigNamesResource} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfiguration(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfiguration(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfiguration(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateConfigurationWithHttpOperationResponse(resourceGroupName, name, siteConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConfigurationWithHttpOperationResponse(resourceGroupName, name, siteConfig, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConfiguration(resourceGroupName, name, siteConfig, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConfiguration(resourceGroupName, name, siteConfig, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConfigurationSnapshotInfoWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConfigurationSnapshotInfo(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConfigurationSnapshotInfo(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConfigurationSnapshotInfo(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConfigurationSnapshotInfo(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSnapshotWithHttpOperationResponse(resourceGroupName, name, snapshotId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback);
    }
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSiteConfigurationSnapshotWithHttpOperationResponse(resourceGroupName, name, snapshotId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeployments(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeployments(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeployments(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeployments(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeploymentWithHttpOperationResponse(resourceGroupName, name, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeployment(resourceGroupName, name, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeployment(resourceGroupName, name, id, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDeploymentWithHttpOperationResponse(resourceGroupName, name, id, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDeployment(resourceGroupName, name, id, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDeployment(resourceGroupName, name, id, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDeployment(resourceGroupName, name, id, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDeployment(resourceGroupName, name, id, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDeploymentWithHttpOperationResponse(resourceGroupName, name, id, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDeployment(resourceGroupName, name, id, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDeployment(resourceGroupName, name, id, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDeployment(resourceGroupName, name, id, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiers(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiers(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDomainOwnershipIdentifierWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindings(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindings(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindings(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindings(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, hostNameBinding, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHostNameBindingWithHttpOperationResponse(resourceGroupName, name, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHostNameBinding(resourceGroupName, name, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHostNameBinding(resourceGroupName, name, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateHybridConnectionWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnectionKey>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionKeysWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnectionKey} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnectionKey} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listRelayServiceConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listRelayServiceConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listRelayServiceConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listRelayServiceConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listRelayServiceConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRelayServiceConnection(resourceGroupName, name, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRelayServiceConnectionWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiers(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiers(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiers(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsWithHttpOperationResponse(resourceGroupName, name, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeployments(resourceGroupName, name, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeployments(resourceGroupName, name, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeployments(resourceGroupName, name, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeployments(resourceGroupName, name, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createInstanceDeployment(resourceGroupName, name, id, instanceId, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteInstanceDeploymentWithHttpOperationResponse(resourceGroupName, name, id, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteInstanceDeployment(resourceGroupName, name, id, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteCloneability>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  isCloneableWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._isCloneable(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteCloneability} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteCloneability} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  isCloneable(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._isCloneable(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._isCloneable(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitions(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitions(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitions(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitions(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetrics(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetrics(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetrics(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetrics(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * <code>true</code>if the app should be switched over; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
   * if the app should be read only during copy operation; otherwise,
   * <code>false</code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageMigrationResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  migrateStorageWithHttpOperationResponse(subscriptionName, resourceGroupName, name, migrationOptions, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * <code>true</code>if the app should be switched over; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
   * if the app should be read only during copy operation; otherwise,
   * <code>false</code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageMigrationResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageMigrationResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._migrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback);
    }
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Operation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  migrateMySqlWithHttpOperationResponse(resourceGroupName, name, migrationRequestEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Operation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Operation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._migrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MigrateMySqlStatus>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMigrateMySqlStatusWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMigrateMySqlStatus(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MigrateMySqlStatus} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MigrateMySqlStatus} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMigrateMySqlStatus(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMigrateMySqlStatus(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMigrateMySqlStatus(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NetworkFeatures>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNetworkFeaturesWithHttpOperationResponse(resourceGroupName, name, view, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNetworkFeatures(resourceGroupName, name, view, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NetworkFeatures} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NetworkFeatures} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNetworkFeatures(resourceGroupName, name, view, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNetworkFeatures(resourceGroupName, name, view, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNetworkFeatures(resourceGroupName, name, view, options, optionalCallback);
    }
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWebSiteNetworkTraceWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWebSiteNetworkTraceWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopWebSiteNetworkTrace(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopWebSiteNetworkTrace(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  generateNewSitePublishingPasswordWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._generateNewSitePublishingPassword(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  generateNewSitePublishingPassword(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._generateNewSitePublishingPassword(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._generateNewSitePublishingPassword(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCounters(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCounters(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCounters(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCounters(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SitePhpErrorLogFlag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSitePhpErrorLogFlagWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSitePhpErrorLogFlag(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SitePhpErrorLogFlag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SitePhpErrorLogFlag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSitePhpErrorLogFlag(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSitePhpErrorLogFlag(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSitePhpErrorLogFlag(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPremierAddOnsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPremierAddOns(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPremierAddOns(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPremierAddOns(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPremierAddOns(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addPremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletePremierAddOnWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deletePremierAddOn(resourceGroupName, name, premierAddOnName, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingProfileXmlWithSecretsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingProfileXmlWithSecrets(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recover(resourceGroupName, name, recoveryEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recover(resourceGroupName, name, recoveryEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetProductionSlotConfigWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetProductionSlotConfig(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetProductionSlotConfig(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetProductionSlotConfig(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetProductionSlotConfig(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restart(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restart(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restart(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restart(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlots(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlots(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlots(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlots(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the details of a web, mobile, or API app.
   *
   * Gets the details of a web, mobile, or API app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSlotWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {string} slot Name of the deployment slot to delete. By default, the
   * API deletes the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * Deletes a web, mobile, or API app, or one of the deployment slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app to delete.
   *
   * @param {string} slot Name of the deployment slot to delete. By default, the
   * API deletes the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.deleteMetrics] If true, web app metrics are also
   * deleted
   *
   * @param {boolean} [options.deleteEmptyServerFarm] Specify true if the App
   * Service plan will be empty after app deletion and you want to delete the
   * empty App Service plan. By default, the empty App Service plan is not
   * deleted.
   *
   * @param {boolean} [options.skipDnsRegistration] If true, DNS registration is
   * skipped
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CustomHostnameAnalysisResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  analyzeCustomHostnameSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Analyze a custom hostname.
   *
   * Analyze a custom hostname.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.hostName] Custom hostname
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CustomHostnameAnalysisResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CustomHostnameAnalysisResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._analyzeCustomHostnameSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  applySlotConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Applies the configuration settings from the target slot onto the
   * current slot.
   *
   * Applies the configuration settings from the target slot onto the current
   * slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._applySlotConfigurationSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a backup for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  backupSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._backupSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a backup of an app.
   *
   * Creates a backup of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Backup configuration. You can use the JSON response
   * from the POST action as input here.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a backup for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  backupSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._backupSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._backupSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get backups of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get backups of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will perform discovery for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  discoverRestoreSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Discovers an existing app backup that can be restored from a blob
   * in Azure storage.
   *
   * Discovers an existing app backup that can be restored from a blob in Azure
   * storage.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request A RestoreRequest object that includes Azure storage
   * URL and blog name for discovery of backup.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will perform discovery for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  discoverRestoreSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._discoverRestoreSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupStatusSlotWithHttpOperationResponse(resourceGroupName, name, backupId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a backup of an app by its ID.
   *
   * Gets a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupStatusSlot(resourceGroupName, name, backupId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupSlotWithHttpOperationResponse(resourceGroupName, name, backupId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a backup of an app by its ID.
   *
   * Deletes a backup of an app by its ID.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupSlot(resourceGroupName, name, backupId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupSlot(resourceGroupName, name, backupId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItem>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupStatusSecretsSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets status of a web app backup that may be in progress, including
   * secrets associated with the backup, such as the Azure Storage SAS URL. Also
   * can be used to update the SAS URL for the backup if a new URL is passed in
   * the request body.
   *
   * Gets status of a web app backup that may be in progress, including secrets
   * associated with the backup, such as the Azure Storage SAS URL. Also can be
   * used to update the SAS URL for the backup if a new URL is passed in the
   * request body.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} backupId Id of backup
   *
   * @param {object} request Information on backup request
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItem} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItem} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupStatusSecretsSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restoreSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateApplicationSettingsSlotWithHttpOperationResponse(resourceGroupName, name, appSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the application settings of an app.
   *
   * Replaces the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} appSettings Application settings of the app.
   *
   * @param {object} [appSettings.properties] Settings.
   *
   * @param {string} [appSettings.name] Resource Name.
   *
   * @param {string} [appSettings.kind] Kind of resource.
   *
   * @param {string} appSettings.location Resource Location.
   *
   * @param {string} [appSettings.type] Resource type.
   *
   * @param {object} [appSettings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateApplicationSettingsSlot(resourceGroupName, name, appSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listApplicationSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the application settings of an app.
   *
   * Gets the application settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the application settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listApplicationSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listApplicationSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, <code>false</code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, <code>false</code>.
   * The default is <code>false</code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the <code>ClientID</code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAuthSettingsSlotWithHttpOperationResponse(resourceGroupName, name, siteAuthSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Authentication / Authorization settings associated with
   * web app.
   *
   * Updates the Authentication / Authorization settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} siteAuthSettings Auth settings associated with web app
   *
   * @param {boolean} [siteAuthSettings.enabled] <code>true</code> if the
   * Authentication / Authorization feature is enabled for the current app;
   * otherwise, <code>false</code>.
   *
   * @param {string} [siteAuthSettings.runtimeVersion] The RuntimeVersion of the
   * Authentication / Authorization feature in use for the current app.
   * The setting in this value can control the behavior of certain features in
   * the Authentication / Authorization module.
   *
   * @param {string} [siteAuthSettings.unauthenticatedClientAction] The action to
   * take when an unauthenticated client attempts to access the app. Possible
   * values include: 'RedirectToLoginPage', 'AllowAnonymous'
   *
   * @param {boolean} [siteAuthSettings.tokenStoreEnabled] <code>true</code> to
   * durably store platform-specific security tokens that are obtained during
   * login flows; otherwise, <code>false</code>.
   * The default is <code>false</code>.
   *
   * @param {array} [siteAuthSettings.allowedExternalRedirectUrls] External URLs
   * that can be redirected to as part of logging in or logging out of the app.
   * Note that the query string part of the URL is ignored.
   * This is an advanced setting typically only needed by Windows Store
   * application backends.
   * Note that URLs within the current domain are always implicitly allowed.
   *
   * @param {string} [siteAuthSettings.defaultProvider] The default
   * authentication provider to use when multiple providers are configured.
   * This setting is only needed if multiple providers are configured and the
   * unauthenticated client
   * action is set to "RedirectToLoginPage". Possible values include:
   * 'AzureActiveDirectory', 'Facebook', 'Google', 'MicrosoftAccount', 'Twitter'
   *
   * @param {number} [siteAuthSettings.tokenRefreshExtensionHours] The number of
   * hours after session token expiration that a session token can be used to
   * call the token refresh API. The default is 72 hours.
   *
   * @param {string} [siteAuthSettings.clientId] The Client ID of this relying
   * party application, known as the client_id.
   * This setting is required for enabling OpenID Connection authentication with
   * Azure Active Directory or
   * other 3rd party OpenID Connect providers.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.clientSecret] The Client Secret of this
   * relying party application (in Azure Active Directory, this is also referred
   * to as the Key).
   * This setting is optional. If no client secret is configured, the OpenID
   * Connect implicit auth flow is used to authenticate end users.
   * Otherwise, the OpenID Connect Authorization Code Flow is used to
   * authenticate end users.
   * More information on OpenID Connect:
   * http://openid.net/specs/openid-connect-core-1_0.html
   *
   * @param {string} [siteAuthSettings.issuer] The OpenID Connect Issuer URI that
   * represents the entity which issues access tokens for this application.
   * When using Azure Active Directory, this value is the URI of the directory
   * tenant, e.g. https://sts.windows.net/{tenant-guid}/.
   * This URI is a case-sensitive identifier for the token issuer.
   * More information on OpenID Connect Discovery:
   * http://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @param {array} [siteAuthSettings.allowedAudiences] Allowed audience values
   * to consider when validating JWTs issued by
   * Azure Active Directory. Note that the <code>ClientID</code> value is always
   * considered an
   * allowed audience, regardless of this setting.
   *
   * @param {array} [siteAuthSettings.additionalLoginParams] Login parameters to
   * send to the OpenID Connect authorization endpoint when
   * a user logs in. Each parameter must be in the form "key=value".
   *
   * @param {string} [siteAuthSettings.googleClientId] The OpenID Connect Client
   * ID for the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.googleClientSecret] The client secret
   * associated with the Google web application.
   * This setting is required for enabling Google Sign-In.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {array} [siteAuthSettings.googleOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Google Sign-In authentication.
   * This setting is optional. If not specified, "openid", "profile", and "email"
   * are used as default scopes.
   * Google Sign-In documentation:
   * https://developers.google.com/identity/sign-in/web/
   *
   * @param {string} [siteAuthSettings.facebookAppId] The App ID of the Facebook
   * app used for login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.facebookAppSecret] The App Secret of the
   * Facebook app used for Facebook Login.
   * This setting is required for enabling Facebook Login.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {array} [siteAuthSettings.facebookOAuthScopes] The OAuth 2.0 scopes
   * that will be requested as part of Facebook Login authentication.
   * This setting is optional.
   * Facebook Login documentation:
   * https://developers.facebook.com/docs/facebook-login
   *
   * @param {string} [siteAuthSettings.twitterConsumerKey] The OAuth 1.0a
   * consumer key of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.twitterConsumerSecret] The OAuth 1.0a
   * consumer secret of the Twitter application used for sign-in.
   * This setting is required for enabling Twitter Sign-In.
   * Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientId] The OAuth 2.0
   * client ID that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {string} [siteAuthSettings.microsoftAccountClientSecret] The OAuth
   * 2.0 client secret that was created for the app used for authentication.
   * This setting is required for enabling Microsoft Account authentication.
   * Microsoft Account OAuth documentation:
   * https://dev.onedrive.com/auth/msa_oauth.htm
   *
   * @param {array} [siteAuthSettings.microsoftAccountOAuthScopes] The OAuth 2.0
   * scopes that will be requested as part of Microsoft Account authentication.
   * This setting is optional. If not specified, "wl.basic" is used as the
   * default scope.
   * Microsoft Account Scopes and permissions documentation:
   * https://msdn.microsoft.com/en-us/library/dn631845.aspx
   *
   * @param {string} [siteAuthSettings.name] Resource Name.
   *
   * @param {string} [siteAuthSettings.kind] Kind of resource.
   *
   * @param {string} siteAuthSettings.location Resource Location.
   *
   * @param {string} [siteAuthSettings.type] Resource type.
   *
   * @param {object} [siteAuthSettings.tags] Resource tags.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAuthSettingsSlot(resourceGroupName, name, siteAuthSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteAuthSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAuthSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAuthSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Authentication/Authorization settings of an app.
   *
   * Gets the Authentication/Authorization settings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteAuthSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteAuthSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAuthSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAuthSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAuthSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the backup configuration of an app.
   *
   * Updates the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} request Edited backup configuration.
   *
   * @param {string} [request.backupRequestName] Name of the backup.
   *
   * @param {boolean} [request.enabled] True if the backup schedule is enabled
   * (must be included in that case), false if the backup schedule should be
   * disabled.
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {object} [request.backupSchedule] Schedule for the backup if it is
   * executed periodically.
   *
   * @param {number} request.backupSchedule.frequencyInterval How often should be
   * the backup executed (e.g. for weekly backup, this should be set to 7 and
   * FrequencyUnit should be set to Day)
   *
   * @param {string} request.backupSchedule.frequencyUnit The unit of time for
   * how often should be the backup executed (e.g. for weekly backup, this should
   * be set to Day and FrequencyInterval should be set to 7). Possible values
   * include: 'Day', 'Hour'
   *
   * @param {boolean} request.backupSchedule.keepAtLeastOneBackup True if the
   * retention policy should always keep at least one backup in the storage
   * account, regardless how old it is; false otherwise.
   *
   * @param {number} request.backupSchedule.retentionPeriodInDays After how many
   * days backups should be deleted.
   *
   * @param {date} [request.backupSchedule.startTime] When the schedule should
   * start working.
   *
   * @param {array} [request.databases] Databases included in the backup.
   *
   * @param {string} [request.backupRequestType] Type of the backup. Possible
   * values include: 'Default', 'Clone', 'Relocation'
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateBackupConfigurationSlot(resourceGroupName, name, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the backup configuration of an app.
   *
   * Deletes the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupRequest>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getBackupConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the backup configuration of an app.
   *
   * Gets the backup configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the backup configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupRequest} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupRequest} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getBackupConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the connection settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConnectionStringsSlotWithHttpOperationResponse(resourceGroupName, name, connectionStrings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the connection strings of an app.
   *
   * Replaces the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} connectionStrings Connection strings of the app or
   * deployment slot. See example.
   *
   * @param {object} [connectionStrings.properties] Connection strings.
   *
   * @param {string} [connectionStrings.name] Resource Name.
   *
   * @param {string} [connectionStrings.kind] Kind of resource.
   *
   * @param {string} connectionStrings.location Resource Location.
   *
   * @param {string} [connectionStrings.type] Resource type.
   *
   * @param {object} [connectionStrings.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the connection settings for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConnectionStringsSlot(resourceGroupName, name, connectionStrings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the connection settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ConnectionStringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConnectionStringsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConnectionStringsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the connection strings of an app.
   *
   * Gets the connection strings of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the connection settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ConnectionStringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ConnectionStringDictionary} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConnectionStringsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConnectionStringsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConnectionStringsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDiagnosticLogsConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the logging configuration of an app.
   *
   * Gets the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteLogsConfig>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDiagnosticLogsConfigSlotWithHttpOperationResponse(resourceGroupName, name, siteLogsConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the logging configuration of an app.
   *
   * Updates the logging configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteLogsConfig A SiteLogsConfig JSON object that contains
   * the logging configuration to change in the "properties" property.
   *
   * @param {object} [siteLogsConfig.applicationLogs] Application logs
   * configuration.
   *
   * @param {object} [siteLogsConfig.applicationLogs.fileSystem] Application logs
   * to file system configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.fileSystem.level] Log level.
   * Possible values include: 'Off', 'Verbose', 'Information', 'Warning', 'Error'
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureTableStorage]
   * Application logs to azure table storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureTableStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} siteLogsConfig.applicationLogs.azureTableStorage.sasUrl SAS
   * URL to an Azure table with add/query/delete permissions.
   *
   * @param {object} [siteLogsConfig.applicationLogs.azureBlobStorage]
   * Application logs to blob storage configuration.
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.level] Log
   * level. Possible values include: 'Off', 'Verbose', 'Information', 'Warning',
   * 'Error'
   *
   * @param {string} [siteLogsConfig.applicationLogs.azureBlobStorage.sasUrl] SAS
   * url to a azure blob container with read/write/list/delete permissions.
   *
   * @param {number}
   * [siteLogsConfig.applicationLogs.azureBlobStorage.retentionInDays] Retention
   * in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {object} [siteLogsConfig.httpLogs] HTTP logs configuration.
   *
   * @param {object} [siteLogsConfig.httpLogs.fileSystem] Http logs to file
   * system configuration.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInMb] Maximum
   * size in megabytes that http log files can use.
   * When reached old log files will be removed to make space for new ones.
   * Value can range between 25 and 100.
   *
   * @param {number} [siteLogsConfig.httpLogs.fileSystem.retentionInDays]
   * Retention in days.
   * Remove files older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.fileSystem.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.httpLogs.azureBlobStorage] Http logs to
   * azure blob storage configuration.
   *
   * @param {string} [siteLogsConfig.httpLogs.azureBlobStorage.sasUrl] SAS url to
   * a azure blob container with read/write/list/delete permissions.
   *
   * @param {number} [siteLogsConfig.httpLogs.azureBlobStorage.retentionInDays]
   * Retention in days.
   * Remove blobs older than X days.
   * 0 or lower means no retention.
   *
   * @param {boolean} [siteLogsConfig.httpLogs.azureBlobStorage.enabled] Enabled.
   *
   * @param {object} [siteLogsConfig.failedRequestsTracing] Failed requests
   * tracing configuration.
   *
   * @param {object} [siteLogsConfig.detailedErrorMessages] Detailed error
   * messages configuration.
   *
   * @param {boolean} [siteLogsConfig.detailedErrorMessages.enabled] Enabled.
   *
   * @param {string} [siteLogsConfig.name] Resource Name.
   *
   * @param {string} [siteLogsConfig.kind] Kind of resource.
   *
   * @param {string} siteLogsConfig.location Resource Location.
   *
   * @param {string} [siteLogsConfig.type] Resource type.
   *
   * @param {object} [siteLogsConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the logging configuration for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteLogsConfig} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteLogsConfig} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDiagnosticLogsConfigSlot(resourceGroupName, name, siteLogsConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateMetadataSlotWithHttpOperationResponse(resourceGroupName, name, metadata, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Replaces the metadata of an app.
   *
   * Replaces the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} metadata Edited metadata of the app or deployment slot. See
   * example.
   *
   * @param {object} [metadata.properties] Settings.
   *
   * @param {string} [metadata.name] Resource Name.
   *
   * @param {string} [metadata.kind] Kind of resource.
   *
   * @param {string} metadata.location Resource Location.
   *
   * @param {string} [metadata.type] Resource type.
   *
   * @param {object} [metadata.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateMetadataSlot(resourceGroupName, name, metadata, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateMetadataSlot(resourceGroupName, name, metadata, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StringDictionary>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetadataSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetadataSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the metadata of an app.
   *
   * Gets the metadata of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the metadata for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StringDictionary} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StringDictionary} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetadataSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetadataSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetadataSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingCredentialsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSitePushSettingsSlotWithHttpOperationResponse(resourceGroupName, name, pushSettings, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the Push settings associated with web app.
   *
   * Updates the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} pushSettings Push settings associated with web app
   *
   * @param {boolean} pushSettings.isPushEnabled Gets or sets a flag indicating
   * whether the Push endpoint is enabled.
   *
   * @param {string} [pushSettings.tagWhitelistJson] Gets or sets a JSON string
   * containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [pushSettings.tagsRequiringAuth] Gets or sets a JSON string
   * containing a list of tags that require user authentication to be used in the
   * push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [pushSettings.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSitePushSettingsSlot(resourceGroupName, name, pushSettings, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PushSettings>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSitePushSettingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Push settings associated with web app.
   *
   * Gets the Push settings associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PushSettings} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PushSettings} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSitePushSettingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSitePushSettingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the configuration of an app, such as platform version and
   * bitness, default documents, virtual applications, Always On, etc.
   *
   * Gets the configuration of an app, such as platform version and bitness,
   * default documents, virtual applications, Always On, etc.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, siteConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, siteConfig, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the configuration of an app.
   *
   * Updates the configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteConfig JSON representation of a SiteConfig object. See
   * example.
   *
   * @param {number} [siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteConfig.netFrameworkVersion] .NET Framework version.
   *
   * @param {string} [siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteConfig.linuxFxVersion] Linux App Framework and version
   *
   * @param {boolean} [siteConfig.requestTracingEnabled] <code>true</code> if
   * request tracing is enabled; otherwise, <code>false</code>.
   *
   * @param {date} [siteConfig.requestTracingExpirationTime] Request tracing
   * expiration time.
   *
   * @param {boolean} [siteConfig.remoteDebuggingEnabled] <code>true</code> if
   * remote debugging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.remoteDebuggingVersion] Remote debugging
   * version.
   *
   * @param {boolean} [siteConfig.httpLoggingEnabled] <code>true</code> if HTTP
   * logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteConfig.logsDirectorySizeLimit] HTTP logs directory size
   * limit.
   *
   * @param {boolean} [siteConfig.detailedErrorLoggingEnabled] <code>true</code>
   * if detailed error logging is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.publishingUsername] Publishing user name.
   *
   * @param {array} [siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteConfig.connectionStrings] Connection strings.
   *
   * @param {array} [siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteConfig.scmType] SCM type. Possible values include:
   * 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit', 'CodePlexHg',
   * 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg', 'OneDrive',
   * 'VSO'
   *
   * @param {boolean} [siteConfig.use32BitWorkerProcess] <code>true</code> to use
   * 32-bit worker process; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.webSocketsEnabled] <code>true</code> if
   * WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteConfig.alwaysOn] <code>true</code> if Always On is
   * enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteConfig.javaContainerVersion] Java container version.
   *
   * @param {string} [siteConfig.appCommandLine] App command line to launch.
   *
   * @param {string} [siteConfig.managedPipelineMode] Managed pipeline mode.
   * Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteConfig.virtualApplications] Virtual applications.
   *
   * @param {string} [siteConfig.loadBalancing] Site load balancing. Possible
   * values include: 'WeightedRoundRobin', 'LeastRequests', 'LeastResponseTime',
   * 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteConfig.experiments] This is work around for polymophic
   * types.
   *
   * @param {array} [siteConfig.experiments.rampUpRules] List of ramp-up rules.
   *
   * @param {object} [siteConfig.limits] Site limits.
   *
   * @param {number} [siteConfig.limits.maxPercentageCpu] Maximum allowed CPU
   * usage percentage.
   *
   * @param {number} [siteConfig.limits.maxMemoryInMb] Maximum allowed memory
   * usage in MB.
   *
   * @param {number} [siteConfig.limits.maxDiskSizeInMb] Maximum allowed disk
   * size usage in MB.
   *
   * @param {boolean} [siteConfig.autoHealEnabled] <code>true</code> if Auto Heal
   * is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteConfig.autoHealRules.triggers] Conditions that describe
   * when to execute the auto-heal actions.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.requests] A rule based on
   * total requests.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.requests.timeInterval]
   * Time interval.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteConfig.autoHealRules.triggers.statusCodes] A rule based
   * on status codes.
   *
   * @param {object} [siteConfig.autoHealRules.triggers.slowRequests] A rule
   * based on request execution time.
   *
   * @param {string} [siteConfig.autoHealRules.triggers.slowRequests.timeTaken]
   * Time taken.
   *
   * @param {number} [siteConfig.autoHealRules.triggers.slowRequests.count]
   * Count.
   *
   * @param {string}
   * [siteConfig.autoHealRules.triggers.slowRequests.timeInterval] Time interval.
   *
   * @param {object} [siteConfig.autoHealRules.actions] Actions to be executed
   * when a rule is triggered.
   *
   * @param {string} [siteConfig.autoHealRules.actions.actionType] Predefined
   * action to be taken. Possible values include: 'Recycle', 'LogEvent',
   * 'CustomAction'
   *
   * @param {object} [siteConfig.autoHealRules.actions.customAction] Custom
   * action to be taken.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.exe]
   * Executable to be run.
   *
   * @param {string} [siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string} [siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteConfig.cors] Cross-Origin Resource Sharing (CORS)
   * settings.
   *
   * @param {array} [siteConfig.cors.allowedOrigins] Gets or sets the list of
   * origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteConfig.push.isPushEnabled Gets or sets a flag
   * indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteConfig.push.tagWhitelistJson] Gets or sets a JSON
   * string containing a list of tags that are whitelisted for use by the push
   * registration endpoint.
   *
   * @param {string} [siteConfig.push.tagsRequiringAuth] Gets or sets a JSON
   * string containing a list of tags that require user authentication to be used
   * in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteConfig.push.dynamicTagsJson] Gets or sets a JSON string
   * containing a list of dynamic tags that will be evaluated from user claims in
   * the push registration endpoint.
   *
   * @param {object} [siteConfig.apiDefinition] Information about the formal API
   * definition for the app.
   *
   * @param {string} [siteConfig.apiDefinition.url] The URL of the API
   * definition.
   *
   * @param {string} [siteConfig.autoSwapSlotName] Auto-swap slot name.
   *
   * @param {boolean} [siteConfig.localMySqlEnabled] <code>true</code> to enable
   * local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteConfig.ipSecurityRestrictions] IP security restrictions.
   *
   * @param {string} [siteConfig.name] Resource Name.
   *
   * @param {string} [siteConfig.kind] Kind of resource.
   *
   * @param {string} siteConfig.location Resource Location.
   *
   * @param {string} [siteConfig.type] Resource type.
   *
   * @param {object} [siteConfig.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateConfigurationSlot(resourceGroupName, name, siteConfig, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConfigurationSnapshotInfoSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a list of web app configuration snapshots identifiers. Each
   * element of the list contains a timestamp and the ID of the snapshot.
   *
   * Gets a list of web app configuration snapshots identifiers. Each element of
   * the list contains a timestamp and the ID of the snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteConfigResource>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getConfigurationSnapshotSlotWithHttpOperationResponse(resourceGroupName, name, snapshotId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a snapshot of the configuration of an app at a previous point
   * in time.
   *
   * Gets a snapshot of the configuration of an app at a previous point in time.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteConfigResource} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteConfigResource} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSiteConfigurationSnapshotSlotWithHttpOperationResponse(resourceGroupName, name, snapshotId, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Reverts the configuration of an app to a previous snapshot.
   *
   * Reverts the configuration of an app to a previous snapshot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} snapshotId The ID of the snapshot to read.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will return configuration for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDeploymentSlot(resourceGroupName, name, id, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get domain ownership identifier for web app.
   *
   * Get domain ownership identifier for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a domain ownership identifier for a web app.
   *
   * Deletes a domain ownership identifier for a web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Identifier>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDomainOwnershipIdentifierSlotWithHttpOperationResponse(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a domain ownership identifier for web app, or updates an
   * existing ownership identifier.
   *
   * Creates a domain ownership identifier for web app, or updates an existing
   * ownership identifier.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} domainOwnershipIdentifierName Name of domain ownership
   * identifier.
   *
   * @param {object} domainOwnershipIdentifier A JSON representation of the
   * domain ownership properties.
   *
   * @param {string} [domainOwnershipIdentifier.identifierId] ID.
   *
   * @param {string} [domainOwnershipIdentifier.name] Resource Name.
   *
   * @param {string} [domainOwnershipIdentifier.kind] Kind of resource.
   *
   * @param {string} domainOwnershipIdentifier.location Resource Location.
   *
   * @param {string} [domainOwnershipIdentifier.type] Resource type.
   *
   * @param {object} [domainOwnershipIdentifier.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Identifier} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Identifier} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets hostname bindings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets hostname bindings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API the named binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, slot, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * Get the named hostname binding for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API the named binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBinding>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, hostName, hostNameBinding, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a hostname binding for an app.
   *
   * Creates a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} hostNameBinding Binding details. This is the JSON
   * representation of a HostNameBinding object.
   *
   * @param {string} [hostNameBinding.hostNameBindingName] Hostname.
   *
   * @param {string} [hostNameBinding.siteName] App Service app name.
   *
   * @param {string} [hostNameBinding.domainId] Fully qualified ARM domain
   * resource URI.
   *
   * @param {string} [hostNameBinding.azureResourceName] Azure resource name.
   *
   * @param {string} [hostNameBinding.azureResourceType] Azure resource type.
   * Possible values include: 'Website', 'TrafficManager'
   *
   * @param {string} [hostNameBinding.customHostNameDnsRecordType] Custom DNS
   * record type. Possible values include: 'CName', 'A'
   *
   * @param {string} [hostNameBinding.hostNameType] Hostname type. Possible
   * values include: 'Verified', 'Managed'
   *
   * @param {string} [hostNameBinding.sslState] SSL type. Possible values
   * include: 'Disabled', 'SniEnabled', 'IpBasedEnabled'
   *
   * @param {string} [hostNameBinding.thumbprint] SSL certificate thumbprint
   *
   * @param {string} [hostNameBinding.virtualIP] Virtual IP address assigned to
   * the hostname if IP based SSL is enabled.
   *
   * @param {string} [hostNameBinding.name] Resource Name.
   *
   * @param {string} [hostNameBinding.kind] Kind of resource.
   *
   * @param {string} hostNameBinding.location Resource Location.
   *
   * @param {string} [hostNameBinding.type] Resource type.
   *
   * @param {object} [hostNameBinding.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create a binding for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBinding} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBinding} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, hostNameBinding, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHostNameBindingSlotWithHttpOperationResponse(resourceGroupName, name, slot, hostName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a hostname binding for an app.
   *
   * Deletes a hostname binding for an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the binding for the production slot.
   *
   * @param {string} hostName Hostname in the hostname binding.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves a specific Service Bus Hybrid Connection used by this Web
   * App.
   *
   * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Removes a Hybrid Connection from this site.
   *
   * Removes a Hybrid Connection from this site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateHybridConnectionSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new Hybrid Connection using a Service Bus relay.
   *
   * Creates a new Hybrid Connection using a Service Bus relay.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {object} connectionEnvelope The details of the hybrid connection
   *
   * @param {string} [connectionEnvelope.serviceBusNamespace] The name of the
   * Service Bus namespace.
   *
   * @param {string} [connectionEnvelope.relayName] The name of the Service Bus
   * relay.
   *
   * @param {string} [connectionEnvelope.relayArmUri] The ARM URI to the Service
   * Bus relay.
   *
   * @param {string} [connectionEnvelope.hostname] The hostname of the endpoint.
   *
   * @param {number} [connectionEnvelope.port] The port of the endpoint.
   *
   * @param {string} [connectionEnvelope.sendKeyName] The name of the Service Bus
   * key which has Send permissions. This is used to authenticate to Service Bus.
   *
   * @param {string} [connectionEnvelope.sendKeyValue] The value of the Service
   * Bus key. This is used to authenticate to Service Bus. In ARM this key will
   * not be returned
   * normally, use the POST /listKeys API instead.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnectionKey>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionKeysSlotWithHttpOperationResponse(resourceGroupName, name, namespaceName, relayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the send key name and value for a Hybrid Connection.
   *
   * Gets the send key name and value for a Hybrid Connection.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} namespaceName The namespace for this hybrid connection
   *
   * @param {string} relayName The relay name for this hybrid connection
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnectionKey} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnectionKey} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HybridConnection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHybridConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * Retrieves all Service Bus Hybrid Connections used by this Web App.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app
   *
   * @param {string} slot The name of the slot for the web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HybridConnection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HybridConnection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHybridConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHybridConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get hybrid connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listRelayServiceConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets hybrid connections configured for an app (or deployment slot,
   * if specified).
   *
   * Gets hybrid connections configured for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get hybrid connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a hybrid connection configuration by its name.
   *
   * Gets a hybrid connection configuration by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a relay service connection by its name.
   *
   * Deletes a relay service connection by its name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete a hybrid connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RelayServiceConnectionEntity>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateRelayServiceConnectionSlotWithHttpOperationResponse(resourceGroupName, name, entityName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new hybrid connection configuration (PUT), or updates an
   * existing one (PATCH).
   *
   * Creates a new hybrid connection configuration (PUT), or updates an existing
   * one (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} entityName Name of the hybrid connection configuration.
   *
   * @param {object} connectionEnvelope Details of the hybrid connection
   * configuration.
   *
   * @param {string} [connectionEnvelope.entityName]
   *
   * @param {string} [connectionEnvelope.entityConnectionString]
   *
   * @param {string} [connectionEnvelope.resourceType]
   *
   * @param {string} [connectionEnvelope.resourceConnectionString]
   *
   * @param {string} [connectionEnvelope.hostname]
   *
   * @param {number} [connectionEnvelope.port]
   *
   * @param {string} [connectionEnvelope.biztalkUri]
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will create or update a hybrid connection for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RelayServiceConnectionEntity} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RelayServiceConnectionEntity} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets the production slot instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets the production slot instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsSlotWithHttpOperationResponse(resourceGroupName, name, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API returns deployments for the production slot.
   *
   * @param {string} instanceId The ID of a specific scaled-out instance. This is
   * the value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get a deployment by its ID for an app, a specific deployment slot,
   * and/or a specific scaled-out instance.
   *
   * Get a deployment by its ID for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API gets a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Deployment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, deployment, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Create a deployment for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * Create a deployment for an app, a specific deployment slot, and/or a
   * specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id ID of an existing deployment.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API creates a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} deployment Deployment details.
   *
   * @param {string} [deployment.deploymentId] ID.
   *
   * @param {number} [deployment.status] Status.
   *
   * @param {string} [deployment.message] Message.
   *
   * @param {string} [deployment.author] Author.
   *
   * @param {string} [deployment.deployer] Deployer.
   *
   * @param {string} [deployment.authorEmail] Author email.
   *
   * @param {date} [deployment.startTime] Start time.
   *
   * @param {date} [deployment.endTime] End time.
   *
   * @param {boolean} [deployment.active] Active.
   *
   * @param {string} [deployment.details] Detail.
   *
   * @param {string} [deployment.name] Resource Name.
   *
   * @param {string} [deployment.kind] Kind of resource.
   *
   * @param {string} deployment.location Resource Location.
   *
   * @param {string} [deployment.type] Resource type.
   *
   * @param {object} [deployment.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Deployment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Deployment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, deployment, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteInstanceDeploymentSlotWithHttpOperationResponse(resourceGroupName, name, id, slot, instanceId, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a deployment by its ID for an app, a specific deployment
   * slot, and/or a specific scaled-out instance.
   *
   * Delete a deployment by its ID for an app, a specific deployment slot, and/or
   * a specific scaled-out instance.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} id Deployment ID.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API deletes a deployment for the production slot.
   *
   * @param {string} instanceId ID of a specific scaled-out instance. This is the
   * value of the name property in the JSON response from "GET
   * api/sites/{siteName}/instances"
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns information on the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteCloneability>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  isCloneableSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._isCloneableSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * Shows whether an app can be cloned to another resource group or
   * subscription.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. By default, this API
   * returns information on the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteCloneability} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteCloneability} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  isCloneableSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._isCloneableSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._isCloneableSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metric definitions of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metric definitions of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metrics of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get metrics of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.details] Specify "true" to include metric details
   * in the response. It is "false" by default.
   *
   * @param {string} [options.filter] Return only metrics specified in the filter
   * (using OData syntax). For example: $filter=(name.value eq 'Metric1' or
   * name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime
   * eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of the deployment slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MigrateMySqlStatus>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMigrateMySqlStatusSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns the status of MySql in app migration, if one is active, and
   * whether or not MySql in app is enabled
   *
   * Returns the status of MySql in app migration, if one is active, and whether
   * or not MySql in app is enabled
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of the deployment slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MigrateMySqlStatus} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MigrateMySqlStatus} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get network features for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<NetworkFeatures>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNetworkFeaturesSlotWithHttpOperationResponse(resourceGroupName, name, view, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * Gets all network features used by the app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} view The type of view. This can either be "summary" or
   * "detailed".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get network features for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {NetworkFeatures} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link NetworkFeatures} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWebSiteNetworkTraceSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Start capturing network packets for the site.
   *
   * Start capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.durationInSeconds] The duration to keep capturing
   * in seconds.
   *
   * @param {number} [options.maxFrameLength] The maximum frame length in bytes
   * (Optional).
   *
   * @param {string} [options.sasUrl] The Blob URL to store capture file.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<String>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWebSiteNetworkTraceSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stop ongoing capturing network packets for the site.
   *
   * Stop ongoing capturing network packets for the site.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name The name of the web app.
   *
   * @param {string} slot The name of the slot for this web app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {String} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API generate a new publishing password for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  generateNewSitePublishingPasswordSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Generates a new publishing password for an app (or deployment slot,
   * if specified).
   *
   * Generates a new publishing password for an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API generate a new publishing password for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot. **** CURRENTLY UNUSED *****
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot. **** CURRENTLY UNUSED *****
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only usages/metrics specified in the
   * filter. Filter conforms to odata syntax. Example: $filter=(startTime eq
   * '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain
   * eq duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SitePhpErrorLogFlag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSitePhpErrorLogFlagSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets web app's event logs.
   *
   * Gets web app's event logs.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SitePhpErrorLogFlag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SitePhpErrorLogFlag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the premier add-ons for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPremierAddOnsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the premier add-ons of an app.
   *
   * Gets the premier add-ons of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the premier add-ons for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPremierAddOnsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPremierAddOnsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getPremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a named add-on of an app.
   *
   * Gets a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PremierAddOn>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addPremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates a named add-on of an app.
   *
   * Updates a named add-on of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {object} premierAddOn A JSON representation of the edited premier
   * add-on.
   *
   * @param {string} [premierAddOn.sku] SKU.
   *
   * @param {string} [premierAddOn.product] Product.
   *
   * @param {string} [premierAddOn.vendor] Vendor.
   *
   * @param {string} [premierAddOn.premierAddOnName] Name.
   *
   * @param {string} [premierAddOn.premierAddOnLocation] Location.
   *
   * @param {object} [premierAddOn.premierAddOnTags] Tags.
   *
   * @param {string} [premierAddOn.marketplacePublisher] Marketplace publisher.
   *
   * @param {string} [premierAddOn.marketplaceOffer] Marketplace offer.
   *
   * @param {string} [premierAddOn.name] Resource Name.
   *
   * @param {string} [premierAddOn.kind] Kind of resource.
   *
   * @param {string} premierAddOn.location Resource Location.
   *
   * @param {string} [premierAddOn.type] Resource type.
   *
   * @param {object} [premierAddOn.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PremierAddOn} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PremierAddOn} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, premierAddOn, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletePremierAddOnSlotWithHttpOperationResponse(resourceGroupName, name, premierAddOnName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Delete a premier add-on from an app.
   *
   * Delete a premier add-on from an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} premierAddOnName Add-on name.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the named add-on for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing profile for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPublishingProfileXmlWithSecretsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the publishing profile for an app (or deployment slot, if
   * specified).
   *
   * Gets the publishing profile for an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing profile for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.format] Name of the format. Valid values are:
   * FileZilla3
   * WebDeploy -- default
   * Ftp. Possible values include: 'FileZilla3', 'WebDeploy', 'Ftp'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  recoverSlotWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._recoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API resets configuration settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetSlotConfigurationSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * Resets the configuration settings of the current slot if they were
   * previously modified by calling the API with POST.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API resets configuration settings for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetSlotConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetSlotConfigurationSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restart the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  restartSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._restartSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restarts an app (or deployment slot, if specified).
   *
   * Restarts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restart the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.softRestart] Specify true to apply the
   * configuration settings and restarts the app only if necessary. By default,
   * the API always restarts and reprovisions the app.
   *
   * @param {boolean} [options.synchronous] Specify true to block until the app
   * is restarted. By default, it is set to false, and the API responds
   * immediately (asynchronous).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  restartSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._restartSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._restartSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  swapSlotSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._swapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {string} slot Website Slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {string} slot Website Slot
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSourceControlSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSourceControlSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will start the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._startSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will start the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  startSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._startSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._startSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will stop the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stopSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will stop the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stopSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stopSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stopSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  syncRepositorySlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._syncRepositorySlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  syncRepositorySlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._syncRepositorySlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._syncRepositorySlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get quota information of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get quota information of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get virtual network connections for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listVnetConnectionsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get virtual network connections for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listVnetConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listVnetConnectionsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named virtual network for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the named virtual network for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will delete the connection for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionSlotWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update connections for the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionSlot(resourceGroupName, name, vnetName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a gateway for the production slot's Virtual
   * Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get a gateway for the production slot's Virtual
   * Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionGatewaySlotWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will add or update a gateway for the production slot's
   * Virtual Network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesFromProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  swapSlotWithProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._swapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshots(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Website Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshots(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshots(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshots(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSourceControlWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the source control configuration of an app.
   *
   * Gets the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSourceControl(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSourceControl(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateSourceControlWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSourceControlWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes the source control configuration of an app.
   *
   * Deletes the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSourceControl(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSourceControl(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSourceControl(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  startWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._start(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Starts an app (or deployment slot, if specified).
   *
   * Starts an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  start(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._start(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._start(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  stopWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._stop(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Stops an app (or deployment slot, if specified).
   *
   * Stops an app (or deployment slot, if specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  stop(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._stop(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._stop(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  syncRepositoryWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._syncRepository(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Sync web app repository.
   *
   * Sync web app repository.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  syncRepository(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._syncRepository(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._syncRepository(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsages(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] Return only information specified in the
   * filter (using OData syntax). For example: $filter=(name.value eq 'Metric1'
   * or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and
   * endTime eq '2014-12-31T23:59:59Z' and timeGrain eq
   * duration'[Hour|Minute|Day]'.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsages(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsages(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsages(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listVnetConnectionsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listVnetConnections(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the virtual networks the app (or deployment slot) is connected
   * to.
   *
   * Gets the virtual networks the app (or deployment slot) is connected to.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listVnetConnections(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listVnetConnections(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listVnetConnections(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets a virtual network the app (or deployment slot) is connected to
   * by name.
   *
   * Gets a virtual network the app (or deployment slot) is connected to by name.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Deletes a connection from an app (or deployment slot to a named
   * virtual network.
   *
   * Deletes a connection from an app (or deployment slot to a named virtual
   * network.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the virtual network.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteVnetConnection(resourceGroupName, name, vnetName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteVnetConnection(resourceGroupName, name, vnetName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetInfo>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionWithHttpOperationResponse(resourceGroupName, name, vnetName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a Virtual Network connection to an app or slot (PUT) or
   * updates the connection properties (PATCH).
   *
   * Adds a Virtual Network connection to an app or slot (PUT) or updates the
   * connection properties (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of an existing Virtual Network.
   *
   * @param {object} connectionEnvelope Properties of the Virtual Network
   * connection. See example.
   *
   * @param {string} [connectionEnvelope.vnetResourceId] The Virtual Network's
   * resource ID.
   *
   * @param {string} [connectionEnvelope.certBlob] A certificate file (.cer) blob
   * containing the public key of the private key used to authenticate a
   * Point-To-Site VPN connection.
   *
   * @param {string} [connectionEnvelope.dnsServers] DNS servers to be used by
   * this Virtual Network. This should be a comma-separated list of IP addresses.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetInfo} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetInfo} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's Virtual Network gateway.
   *
   * Gets an app's Virtual Network gateway.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VnetGateway>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateVnetConnectionGatewayWithHttpOperationResponse(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Adds a gateway to a connected Virtual Network (PUT) or updates it
   * (PATCH).
   *
   * Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} vnetName Name of the Virtual Network.
   *
   * @param {string} gatewayName Name of the gateway. Currently, the only
   * supported string is "primary".
   *
   * @param {object} connectionEnvelope The properties to update this gateway
   * with.
   *
   * @param {string} [connectionEnvelope.vnetName] The Virtual Network name.
   *
   * @param {string} [connectionEnvelope.vpnPackageUri] The URI where the VPN
   * package can be downloaded.
   *
   * @param {string} [connectionEnvelope.name] Resource Name.
   *
   * @param {string} [connectionEnvelope.kind] Kind of resource.
   *
   * @param {string} connectionEnvelope.location Resource Location.
   *
   * @param {string} [connectionEnvelope.type] Resource type.
   *
   * @param {object} [connectionEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VnetGateway} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VnetGateway} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRestoreWithHttpOperationResponse(resourceGroupName, name, backupId, request, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRestore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRestore(resourceGroupName, name, backupId, request, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRestore(resourceGroupName, name, backupId, request, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRestore(resourceGroupName, name, backupId, request, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginListPublishingCredentialsWithHttpOperationResponse(resourceGroupName, name, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginListPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginListPublishingCredentials(resourceGroupName, name, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginListPublishingCredentials(resourceGroupName, name, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginListPublishingCredentials(resourceGroupName, name, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * <code>true</code>if the app should be switched over; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
   * if the app should be read only during copy operation; otherwise,
   * <code>false</code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<StorageMigrationResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginMigrateStorageWithHttpOperationResponse(subscriptionName, resourceGroupName, name, migrationOptions, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a web app.
   *
   * Restores a web app.
   *
   * @param {string} subscriptionName Azure subscription
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationOptions Migration migrationOptions
   *
   * @param {string} [migrationOptions.azurefilesConnectionString] AzureFiles
   * connection string.
   *
   * @param {string} [migrationOptions.azurefilesShare] AzureFiles share.
   *
   * @param {boolean} [migrationOptions.switchSiteAfterMigration]
   * <code>true</code>if the app should be switched over; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [migrationOptions.blockWriteAccessToSite] <code>true</code>
   * if the app should be read only during copy operation; otherwise,
   * <code>false</code>.
   *
   * @param {string} [migrationOptions.name] Resource Name.
   *
   * @param {string} [migrationOptions.kind] Kind of resource.
   *
   * @param {string} migrationOptions.location Resource Location.
   *
   * @param {string} [migrationOptions.type] Resource type.
   *
   * @param {object} [migrationOptions.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {StorageMigrationResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link StorageMigrationResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options, optionalCallback);
    }
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Operation>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginMigrateMySqlWithHttpOperationResponse(resourceGroupName, name, migrationRequestEnvelope, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Migrates a local (in-app) MySql database to a remote MySql
   * database.
   *
   * Migrates a local (in-app) MySql database to a remote MySql database.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} migrationRequestEnvelope MySql migration options
   *
   * @param {string} [migrationRequestEnvelope.connectionString] Connection
   * string to the remote MySQL database to which data should be migrated.
   *
   * @param {string} [migrationRequestEnvelope.name] Resource Name.
   *
   * @param {string} [migrationRequestEnvelope.kind] Kind of resource.
   *
   * @param {string} migrationRequestEnvelope.location Resource Location.
   *
   * @param {string} [migrationRequestEnvelope.type] Resource type.
   *
   * @param {object} [migrationRequestEnvelope.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Operation} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Operation} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRecoverWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRecover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRecover(resourceGroupName, name, recoveryEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRecover(resourceGroupName, name, recoveryEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRecover(resourceGroupName, name, recoveryEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Site>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSlotWithHttpOperationResponse(resourceGroupName, name, siteEnvelope, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Creates a new web, mobile, or API app in an existing resource
   * group, or updates an existing app.
   *
   * Creates a new web, mobile, or API app in an existing resource group, or
   * updates an existing app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Unique name of the app to create or update. To create
   * or update a deployment slot, use the {slot} parameter.
   *
   * @param {object} siteEnvelope A JSON representation of the app properties.
   * See example.
   *
   * @param {boolean} [siteEnvelope.enabled] <code>true</code> if the app is
   * enabled; otherwise, <code>false</code>. Setting this value to false disables
   * the app (takes the app offline).
   *
   * @param {array} [siteEnvelope.hostNameSslStates] Hostname SSL states are used
   * to manage the SSL bindings for app's hostnames.
   *
   * @param {string} [siteEnvelope.serverFarmId] Resource ID of the associated
   * App Service plan, formatted as:
   * "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
   *
   * @param {boolean} [siteEnvelope.reserved] <code>true</code> if reserved;
   * otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig] Configuration of the app.
   *
   * @param {number} [siteEnvelope.siteConfig.numberOfWorkers] Number of workers.
   *
   * @param {array} [siteEnvelope.siteConfig.defaultDocuments] Default documents.
   *
   * @param {string} [siteEnvelope.siteConfig.netFrameworkVersion] .NET Framework
   * version.
   *
   * @param {string} [siteEnvelope.siteConfig.phpVersion] Version of PHP.
   *
   * @param {string} [siteEnvelope.siteConfig.pythonVersion] Version of Python.
   *
   * @param {string} [siteEnvelope.siteConfig.nodeVersion] Version of Node.js.
   *
   * @param {string} [siteEnvelope.siteConfig.linuxFxVersion] Linux App Framework
   * and version
   *
   * @param {boolean} [siteEnvelope.siteConfig.requestTracingEnabled]
   * <code>true</code> if request tracing is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {date} [siteEnvelope.siteConfig.requestTracingExpirationTime] Request
   * tracing expiration time.
   *
   * @param {boolean} [siteEnvelope.siteConfig.remoteDebuggingEnabled]
   * <code>true</code> if remote debugging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.remoteDebuggingVersion] Remote
   * debugging version.
   *
   * @param {boolean} [siteEnvelope.siteConfig.httpLoggingEnabled]
   * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
   *
   * @param {number} [siteEnvelope.siteConfig.logsDirectorySizeLimit] HTTP logs
   * directory size limit.
   *
   * @param {boolean} [siteEnvelope.siteConfig.detailedErrorLoggingEnabled]
   * <code>true</code> if detailed error logging is enabled; otherwise,
   * <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.publishingUsername] Publishing user
   * name.
   *
   * @param {array} [siteEnvelope.siteConfig.appSettings] Application settings.
   *
   * @param {array} [siteEnvelope.siteConfig.connectionStrings] Connection
   * strings.
   *
   * @param {array} [siteEnvelope.siteConfig.handlerMappings] Handler mappings.
   *
   * @param {string} [siteEnvelope.siteConfig.documentRoot] Document root.
   *
   * @param {string} [siteEnvelope.siteConfig.scmType] SCM type. Possible values
   * include: 'None', 'Dropbox', 'Tfs', 'LocalGit', 'GitHub', 'CodePlexGit',
   * 'CodePlexHg', 'BitbucketGit', 'BitbucketHg', 'ExternalGit', 'ExternalHg',
   * 'OneDrive', 'VSO'
   *
   * @param {boolean} [siteEnvelope.siteConfig.use32BitWorkerProcess]
   * <code>true</code> to use 32-bit worker process; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.webSocketsEnabled]
   * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.siteConfig.alwaysOn] <code>true</code> if
   * Always On is enabled; otherwise, <code>false</code>.
   *
   * @param {string} [siteEnvelope.siteConfig.javaVersion] Java version.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainer] Java container.
   *
   * @param {string} [siteEnvelope.siteConfig.javaContainerVersion] Java
   * container version.
   *
   * @param {string} [siteEnvelope.siteConfig.appCommandLine] App command line to
   * launch.
   *
   * @param {string} [siteEnvelope.siteConfig.managedPipelineMode] Managed
   * pipeline mode. Possible values include: 'Integrated', 'Classic'
   *
   * @param {array} [siteEnvelope.siteConfig.virtualApplications] Virtual
   * applications.
   *
   * @param {string} [siteEnvelope.siteConfig.loadBalancing] Site load balancing.
   * Possible values include: 'WeightedRoundRobin', 'LeastRequests',
   * 'LeastResponseTime', 'WeightedTotalTraffic', 'RequestHash'
   *
   * @param {object} [siteEnvelope.siteConfig.experiments] This is work around
   * for polymophic types.
   *
   * @param {array} [siteEnvelope.siteConfig.experiments.rampUpRules] List of
   * ramp-up rules.
   *
   * @param {object} [siteEnvelope.siteConfig.limits] Site limits.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxPercentageCpu] Maximum
   * allowed CPU usage percentage.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxMemoryInMb] Maximum
   * allowed memory usage in MB.
   *
   * @param {number} [siteEnvelope.siteConfig.limits.maxDiskSizeInMb] Maximum
   * allowed disk size usage in MB.
   *
   * @param {boolean} [siteEnvelope.siteConfig.autoHealEnabled] <code>true</code>
   * if Auto Heal is enabled; otherwise, <code>false</code>.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules] Auto Heal rules.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers] Conditions
   * that describe when to execute the auto-heal actions.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.triggers.requests] A
   * rule based on total requests.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.requests.timeInterval] Time
   * interval.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.privateBytesInKB] A rule
   * based on private bytes.
   *
   * @param {array} [siteEnvelope.siteConfig.autoHealRules.triggers.statusCodes]
   * A rule based on status codes.
   *
   * @param {object}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests] A rule based
   * on request execution time.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeTaken] Time
   * taken.
   *
   * @param {number}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.count] Count.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.triggers.slowRequests.timeInterval]
   * Time interval.
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions] Actions to
   * be executed when a rule is triggered.
   *
   * @param {string} [siteEnvelope.siteConfig.autoHealRules.actions.actionType]
   * Predefined action to be taken. Possible values include: 'Recycle',
   * 'LogEvent', 'CustomAction'
   *
   * @param {object} [siteEnvelope.siteConfig.autoHealRules.actions.customAction]
   * Custom action to be taken.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.exe] Executable
   * to be run.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.customAction.parameters]
   * Parameters for the executable.
   *
   * @param {string}
   * [siteEnvelope.siteConfig.autoHealRules.actions.minProcessExecutionTime]
   * Minimum time the process must execute
   * before taking the action
   *
   * @param {string} [siteEnvelope.siteConfig.tracingOptions] Tracing options.
   *
   * @param {string} [siteEnvelope.siteConfig.vnetName] Virtual Network name.
   *
   * @param {object} [siteEnvelope.siteConfig.cors] Cross-Origin Resource Sharing
   * (CORS) settings.
   *
   * @param {array} [siteEnvelope.siteConfig.cors.allowedOrigins] Gets or sets
   * the list of origins that should be allowed to make cross-origin
   * calls (for example: http://example.com:12345). Use "*" to allow all.
   *
   * @param {object} [siteEnvelope.siteConfig.push] Push endpoint settings.
   *
   * @param {boolean} siteEnvelope.siteConfig.push.isPushEnabled Gets or sets a
   * flag indicating whether the Push endpoint is enabled.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagWhitelistJson] Gets or sets
   * a JSON string containing a list of tags that are whitelisted for use by the
   * push registration endpoint.
   *
   * @param {string} [siteEnvelope.siteConfig.push.tagsRequiringAuth] Gets or
   * sets a JSON string containing a list of tags that require user
   * authentication to be used in the push registration endpoint.
   * Tags can consist of alphanumeric characters and the following:
   * '_', '@', '#', '.', ':', '-'.
   * Validation should be performed at the PushRequestHandler.
   *
   * @param {string} [siteEnvelope.siteConfig.push.dynamicTagsJson] Gets or sets
   * a JSON string containing a list of dynamic tags that will be evaluated from
   * user claims in the push registration endpoint.
   *
   * @param {object} [siteEnvelope.siteConfig.apiDefinition] Information about
   * the formal API definition for the app.
   *
   * @param {string} [siteEnvelope.siteConfig.apiDefinition.url] The URL of the
   * API definition.
   *
   * @param {string} [siteEnvelope.siteConfig.autoSwapSlotName] Auto-swap slot
   * name.
   *
   * @param {boolean} [siteEnvelope.siteConfig.localMySqlEnabled]
   * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
   *
   * @param {array} [siteEnvelope.siteConfig.ipSecurityRestrictions] IP security
   * restrictions.
   *
   * @param {boolean} [siteEnvelope.scmSiteAlsoStopped] <code>true</code> to stop
   * SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The
   * default is <code>false</code>.
   *
   * @param {object} [siteEnvelope.hostingEnvironmentProfile] App Service
   * Environment to use for the app.
   *
   * @param {string} [siteEnvelope.hostingEnvironmentProfile.id] Resource ID of
   * the App Service Environment.
   *
   * @param {string} [siteEnvelope.microService] Micro services like apps, logic
   * apps.
   *
   * @param {string} [siteEnvelope.gatewaySiteName] Name of gateway app
   * associated with the app.
   *
   * @param {boolean} [siteEnvelope.clientAffinityEnabled] <code>true</code> to
   * enable client affinity; <code>false</code> to stop sending session affinity
   * cookies, which route client requests in the same session to the same
   * instance. Default is <code>true</code>.
   *
   * @param {boolean} [siteEnvelope.clientCertEnabled] <code>true</code> to
   * enable client certificate authentication (TLS mutual authentication);
   * otherwise, <code>false</code>. Default is <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.hostNamesDisabled] <code>true</code> to
   * disable the public hostnames of the app; otherwise, <code>false</code>.
   * If <code>true</code>, the app is only accessible via API management process.
   *
   * @param {number} [siteEnvelope.containerSize] Size of the function container.
   *
   * @param {number} [siteEnvelope.dailyMemoryTimeQuota] Maximum allowed daily
   * memory-time quota (applicable on dynamic apps only).
   *
   * @param {object} [siteEnvelope.cloningInfo] If specified during app creation,
   * the app is cloned from a source app.
   *
   * @param {string} [siteEnvelope.cloningInfo.correlationId] Correlation ID of
   * cloning operation. This ID ties multiple cloning operations
   * together to use the same snapshot.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.overwrite] <code>true</code> to
   * overwrite destination app; otherwise, <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneCustomHostNames]
   * <code>true</code> to clone custom hostnames from source app; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.cloneSourceControl]
   * <code>true</code> to clone source control from source app; otherwise,
   * <code>false</code>.
   *
   * @param {string} siteEnvelope.cloningInfo.sourceWebAppId ARM resource ID of
   * the source app. App resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}
   * for production slots and
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName}
   * for other slots.
   *
   * @param {string} [siteEnvelope.cloningInfo.hostingEnvironment] App Service
   * Environment.
   *
   * @param {object} [siteEnvelope.cloningInfo.appSettingsOverrides] Application
   * setting overrides for cloned app. If specified, these settings override the
   * settings cloned
   * from source app. Otherwise, application settings from source app are
   * retained.
   *
   * @param {boolean} [siteEnvelope.cloningInfo.configureLoadBalancing]
   * <code>true</code> to configure load balancing for source and destination
   * app.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileId] ARM
   * resource ID of the Traffic Manager profile to use, if it exists. Traffic
   * Manager resource ID is of the form
   * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
   *
   * @param {string} [siteEnvelope.cloningInfo.trafficManagerProfileName] Name of
   * Traffic Manager profile to create. This is only needed if Traffic Manager
   * profile does not already exist.
   *
   * @param {string} [siteEnvelope.name] Resource Name.
   *
   * @param {string} [siteEnvelope.kind] Kind of resource.
   *
   * @param {string} siteEnvelope.location Resource Location.
   *
   * @param {string} [siteEnvelope.type] Resource type.
   *
   * @param {object} [siteEnvelope.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot to create or update. By
   * default, this API attempts to create or modify the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.skipDnsRegistration] If true web app hostname is
   * not registered with DNS on creation. This parameter is
   * only used for app creation
   *
   * @param {boolean} [options.skipCustomDomainVerification] If true, custom (non
   * *.azurewebsites.net) domains associated with web app are not verified.
   *
   * @param {boolean} [options.forceDnsRegistration] If true, web app hostname is
   * force registered with DNS
   *
   * @param {string} [options.ttlInSeconds] Time to live in seconds for web app's
   * default domain name
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Site} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Site} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSlot(resourceGroupName, name, siteEnvelope, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RestoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRestoreSlotWithHttpOperationResponse(resourceGroupName, name, backupId, request, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * Restores a specific backup to another app (or deployment slot, if
   * specified).
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} backupId ID of the backup.
   *
   * @param {object} request Information on restore request
   *
   * @param {string} [request.storageAccountUrl] SAS URL to the container.
   *
   * @param {string} [request.blobName] Name of a blob which contains the backup.
   *
   * @param {boolean} [request.overwrite] <code>true</code> if the restore
   * operation can overwrite target app; otherwise, <code>false</code>.
   * <code>true</code> is needed if trying to restore over an existing app.
   *
   * @param {string} [request.siteName] Name of an app.
   *
   * @param {array} [request.databases] Collection of databases which should be
   * restored. This list has to match the list of databases included in the
   * backup.
   *
   * @param {boolean} [request.ignoreConflictingHostNames] Changes a logic when
   * restoring an app with custom domains. <code>true</code> to remove custom
   * domains automatically. If <code>false</code>, custom domains are added to
   * the app's object when it is being restored, but that might fail due to
   * conflicts during the operation.
   *
   * @param {string} [request.operationType] Operation type. Possible values
   * include: 'Default', 'Clone', 'Relocation'
   *
   * @param {boolean} [request.adjustConnectionStrings] <code>true</code> if
   * SiteConfig.ConnectionStrings should be set in new app; otherwise,
   * <code>false</code>.
   *
   * @param {string} [request.hostingEnvironment] App Service Environment name,
   * if needed (only when restoring an app to an App Service Environment).
   *
   * @param {string} [request.name] Resource Name.
   *
   * @param {string} [request.kind] Kind of resource.
   *
   * @param {string} request.location Resource Location.
   *
   * @param {string} [request.type] Resource type.
   *
   * @param {object} [request.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will restore a backup of the production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RestoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RestoreResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRestoreSlot(resourceGroupName, name, backupId, request, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginListPublishingCredentialsSlotWithHttpOperationResponse(resourceGroupName, name, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the Git/FTP publishing credentials of an app.
   *
   * Gets the Git/FTP publishing credentials of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will get the publishing credentials for the production
   * slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RecoverResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRecoverSlotWithHttpOperationResponse(resourceGroupName, name, recoveryEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Recovers a deleted web app.
   *
   * Recovers a deleted web app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of web app
   *
   * @param {object} recoveryEntity Snapshot data used for web app recovery.
   * Snapshot information can be obtained by calling GetDeletedSites or
   * GetSiteSnapshots API.
   *
   * @param {date} [recoveryEntity.snapshotTime] Point in time in which the app
   * recovery should be attempted.
   *
   * @param {string} [recoveryEntity.siteName] [Optional] Destination app name
   * into which app should be recovered. This is case when new app should be
   * created instead.
   *
   * @param {string} [recoveryEntity.slotName] [Optional] Destination app slot
   * name into which app should be recovered.
   *
   * @param {string} slot Name of web app slot. If not specified then will
   * default to production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RecoverResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RecoverResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRecoverSlot(resourceGroupName, name, recoveryEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginSwapSlotSlotWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {string} slot Name of the source slot. If a slot is not specified,
   * the production slot is used as the source slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginSwapSlotSlot(resourceGroupName, name, slotSwapEntity, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSourceControlSlotWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, slot, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {string} slot Name of the deployment slot. If a slot is not
   * specified, the API will update the source control configuration for the
   * production slot.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, siteSourceControl, slot, options, optionalCallback);
    }
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginSwapSlotWithProductionWithHttpOperationResponse(resourceGroupName, name, slotSwapEntity, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Swaps two deployment slots of an app.
   *
   * Swaps two deployment slots of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} slotSwapEntity JSON object that contains the target slot
   * name. See example.
   *
   * @param {string} slotSwapEntity.targetSlot Destination deployment slot during
   * swap operation.
   *
   * @param {boolean} slotSwapEntity.preserveVnet <code>true</code> to preserve
   * Virtual Network to the slot during swap; otherwise, <code>false</code>.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options, optionalCallback);
    }
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SiteSourceControl>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateSourceControlWithHttpOperationResponse(resourceGroupName, name, siteSourceControl, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Updates the source control configuration of an app.
   *
   * Updates the source control configuration of an app.
   *
   * @param {string} resourceGroupName Name of the resource group to which the
   * resource belongs.
   *
   * @param {string} name Name of the app.
   *
   * @param {object} siteSourceControl JSON representation of a SiteSourceControl
   * object. See example.
   *
   * @param {string} [siteSourceControl.repoUrl] Repository or source control
   * URL.
   *
   * @param {string} [siteSourceControl.branch] Name of branch to use for
   * deployment.
   *
   * @param {boolean} [siteSourceControl.isManualIntegration] <code>true</code>
   * to limit to manual integration; <code>false</code> to enable continuous
   * integration (which configures webhooks into online repos like GitHub).
   *
   * @param {boolean} [siteSourceControl.deploymentRollbackEnabled]
   * <code>true</code> to enable deployment rollback; otherwise,
   * <code>false</code>.
   *
   * @param {boolean} [siteSourceControl.isMercurial] <code>true</code> for a
   * Mercurial repository; <code>false</code> for a Git repository.
   *
   * @param {string} [siteSourceControl.name] Resource Name.
   *
   * @param {string} [siteSourceControl.kind] Kind of resource.
   *
   * @param {string} siteSourceControl.location Resource Location.
   *
   * @param {string} [siteSourceControl.type] Resource type.
   *
   * @param {object} [siteSourceControl.tags] Resource tags.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SiteSourceControl} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SiteSourceControl} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options, optionalCallback);
    }
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get all apps for a subscription.
   *
   * Get all apps for a subscription.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByResourceGroupNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByResourceGroupNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all web, mobile, and API apps in the specified resource group.
   *
   * Gets all web, mobile, and API apps in the specified resource group.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByResourceGroupNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByResourceGroupNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByResourceGroupNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets an app's deployment slots.
   *
   * Gets an app's deployment slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<BackupItemCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listBackupsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listBackupsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets existing backups of an app.
   *
   * Gets existing backups of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {BackupItemCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link BackupItemCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listBackupsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listBackupsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listBackupsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDeploymentsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDeploymentsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDeploymentsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<IdentifierCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listDomainOwnershipIdentifiersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Lists ownership identifiers for domain associated with web app.
   *
   * Lists ownership identifiers for domain associated with web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {IdentifierCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link IdentifierCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listDomainOwnershipIdentifiersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<HostNameBindingCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listHostNameBindingsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listHostNameBindingsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get hostname bindings for an app or a deployment slot.
   *
   * Get hostname bindings for an app or a deployment slot.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {HostNameBindingCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link HostNameBindingCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listHostNameBindingsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listHostNameBindingsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listHostNameBindingsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<WebAppInstanceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceIdentifiersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all scale-out instances of an app.
   *
   * Gets all scale-out instances of an app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {WebAppInstanceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link WebAppInstanceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceIdentifiersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceIdentifiersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceIdentifiersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DeploymentCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listInstanceDeploymentsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listInstanceDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary List deployments for an app, or a deployment slot, or for an
   * instance of a scaled-out app.
   *
   * List deployments for an app, or a deployment slot, or for an instance of a
   * scaled-out app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DeploymentCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DeploymentCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listInstanceDeploymentsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listInstanceDeploymentsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listInstanceDeploymentsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricDefinitionCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitionsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets all metric definitions of an app (or deployment slot, if
   * specified).
   *
   * Gets all metric definitions of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricDefinitionCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricDefinitionCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitionsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitionsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitionsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ResourceMetricCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets performance metrics of an app (or deployment slot, if
   * specified).
   *
   * Gets performance metrics of an app (or deployment slot, if specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {ResourceMetricCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ResourceMetricCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<PerfMonCounterCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listPerfMonCountersSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listPerfMonCountersSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets perfmon counters for web app.
   *
   * Gets perfmon counters for web app.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {PerfMonCounterCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link PerfMonCounterCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listPerfMonCountersSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listPerfMonCountersSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listPerfMonCountersSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesSlotNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesSlotNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesSlotNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesSlotNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesSlotNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SlotDifferenceCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSlotDifferencesFromProductionNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSlotDifferencesFromProductionNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Get the difference in configuration settings between two web app
   * slots.
   *
   * Get the difference in configuration settings between two web app slots.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SlotDifferenceCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SlotDifferenceCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSlotDifferencesFromProductionNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSlotDifferencesFromProductionNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSlotDifferencesFromProductionNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SnapshotCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSnapshotsNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSnapshotsNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Returns all Snapshots to the user.
   *
   * Returns all Snapshots to the user.
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SnapshotCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SnapshotCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSnapshotsNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSnapshotsNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSnapshotsNext(nextPageLink, options, optionalCallback);
    }
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CsmUsageQuotaCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesNextWithHttpOperationResponse(nextPageLink, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsagesNext(nextPageLink, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * Gets the quota usage information of an app (or deployment slot, if
   * specified).
   *
   * @param {string} nextPageLink The NextLink from the previous successful call
   * to List operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CsmUsageQuotaCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CsmUsageQuotaCollection} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsagesNext(nextPageLink, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsagesNext(nextPageLink, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsagesNext(nextPageLink, options, optionalCallback);
    }
  }

}

module.exports = WebApps;
